<!doctype html>
<html data-n-head-ssr lang="zh" data-n-head="%7B%22lang%22:%7B%22ssr%22:%22zh%22%7D%7D">
  <head >
    <title>【Go源码剖析】解读精益求精的 Sync.Mutex - 掘金</title><meta data-n-head="ssr" charset="utf-8"><meta data-n-head="ssr" name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover"><meta data-n-head="ssr" name="apple-itunes-app" content="app-id=987739104"><meta data-n-head="ssr" name="theme-color" content="#ffffff"><meta data-n-head="ssr" name="msapplication-TileColor" content="#da532c"><meta data-n-head="ssr" vmid="description" name="description" content="“互斥锁”对于并发编程是必不可少的，Go语言虽然推崇使用Channel来解决对并发资源的访问，但同样实现了Sync.Mutex互斥锁供编程人员使用。本文就带领大家探索Sync.Mutex的实现。"><meta data-n-head="ssr" vmid="keywords" name="keywords" content="Go,源码"><link data-n-head="ssr" rel="preconnect" href="//unpkg.byted-static.com/" crossorigin="anonymous"><link data-n-head="ssr" rel="preconnect" href="//lf3-cdn-tos.bytescm.com" crossorigin="anonymous"><link data-n-head="ssr" rel="preconnect" href="//mcs.snssdk.com" crossorigin="anonymous"><link data-n-head="ssr" rel="preconnect" href="//i.snssdk.com" crossorigin="anonymous"><link data-n-head="ssr" rel="dns-prefetch" href="//lf3-short.ibytedapm.com"><link data-n-head="ssr" rel="dns-prefetch" href="//lf3-cdn-tos.bytescm.com"><link data-n-head="ssr" rel="dns-prefetch" href="//api.juejin.cn"><link data-n-head="ssr" rel="dns-prefetch" href="//lf-cdn-tos.bytescm.com"><link data-n-head="ssr" rel="dns-prefetch" href="//unpkg.byted-static.com"><link data-n-head="ssr" rel="dns-prefetch" href="//p1-juejin.byteimg.com"><link data-n-head="ssr" rel="dns-prefetch" href="//p3-juejin.byteimg.com"><link data-n-head="ssr" rel="dns-prefetch" href="//p6-juejin.byteimg.com"><link data-n-head="ssr" rel="dns-prefetch" href="//p9-juejin.byteimg.com"><link data-n-head="ssr" rel="dns-prefetch" href="//p1-jj.byteimg.com"><link data-n-head="ssr" rel="dns-prefetch" href="//p2-jj.byteimg.com"><link data-n-head="ssr" rel="dns-prefetch" href="//p6-jj.byteimg.com"><link data-n-head="ssr" rel="dns-prefetch" href="//p9-jj.byteimg.com"><link data-n-head="ssr" rel="dns-prefetch" href="//mcs.snssdk.com"><link data-n-head="ssr" rel="dns-prefetch" href="//i.snssdk.com"><link data-n-head="ssr" rel="apple-touch-icon" sizes="180x180" href="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web//static/favicons/apple-touch-icon.png"><link data-n-head="ssr" rel="icon" type="image/png" sizes="32x32" href="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web//static/favicons/favicon-32x32.png"><link data-n-head="ssr" rel="icon" type="image/png" sizes="16x16" href="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web//static/favicons/favicon-16x16.png"><link data-n-head="ssr" rel="mask-icon" href="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web//static/favicons/safari-pinned-tab.svg" color="#1E80FF"><link data-n-head="ssr" rel="manifest" href="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web//static/favicons/site.webmanifest"><link data-n-head="ssr" rel="search" title="掘金" href="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web//static/search.xml" type="application/opensearchdescription+xml"><link data-n-head="ssr" rel="stylesheet" href="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web//static/bytedesign.min.css"><link data-n-head="ssr" rel="canonical" href="https://juejin.cn/post/6990181431574003726"><script data-n-head="ssr" type="text/javascript" data-sdk-glue-default="load" src="https://lf-headquarters-speed.yhgfb-cn-static.com/obj/rc-client-security/web/glue/1.0.0.13/sdk-glue.js"></script><script data-n-head="ssr" type="text/javascript" data-sdk-glue-default="init">
        (function (){
          var options = {
            bdms: {
              aid: 2608,
              paths: [
                '/growth_api/v1/publish_benefit_history',
                '/growth_api/v1/check_in',
                '/growth_api/v1/lottery/draw',
                '/growth_api/v1/lottery/ten_draw',
                '/web_shorten',
              ]
            }
          }
          window._SdkGlueInit(options)
        })();
        </script><script data-n-head="ssr" vmid="slardar" type="text/javascript" crossorigin="anonymous">;(function (w, d, u, b, n, pc, ga, ae, po, s, p, e, t, pp) {pc = 'precollect';ga = 'getAttribute';ae = 'addEventListener';po = 'PerformanceObserver';s = function (m) {p = [].slice.call(arguments);p.push(Date.now(), location.href);(m == pc ? s.p.a : s.q).push(p)};s.q = [];s.p = { a: [] };w[n] = s;e = document.createElement('script');e.src = u + '?bid=' + b + '&globalName=' + n;e.crossOrigin = u.indexOf('sdk-web') > 0 ? 'anonymous' : 'use-credentials';d.getElementsByTagName('head')[0].appendChild(e);if (ae in w) {s.pcErr = function (e) {e = e || w.event;t = e.target || e.srcElement;if (t instanceof Element || t instanceof HTMLElement) {if (t[ga]('integrity')) {w[n](pc, 'sri', t[ga]('href') || t[ga]('src'))} else {w[n](pc, 'st', { tagName: t.tagName, url: t[ga]('href') || t[ga]('src') })}} else {w[n](pc, 'err', e.error || e.message)}};s.pcRej = function (e) {e = e || w.event;w[n](pc, 'err', e.reason || (e.detail && e.detail.reason))};w[ae]('error', s.pcErr, true);w[ae]('unhandledrejection', s.pcRej, true);};if('PerformanceLongTaskTiming' in w) {pp = s.pp = { entries: [] };pp.observer = new PerformanceObserver(function (l) {pp.entries = pp.entries.concat(l.getEntries())});pp.observer.observe({ entryTypes: ['longtask', 'largest-contentful-paint','layout-shift'] })}})(window,document,'https://lf3-short.ibytedapm.com/slardar/fe/sdk-web/browser.cn.js','2608','SlardarWeb')</script><script data-n-head="ssr" type="text/javascript" src="//unpkg.byted-static.com/latest/byted-imagex/slardar-plugin/browser/imageReport.js"></script><script data-n-head="ssr" type="application/ld+json">[{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://juejin.cn/post/6990181431574003726"},"headline":"【Go源码剖析】解读精益求精的 Sync.Mutex","description":"“互斥锁”对于并发编程是必不可少的，Go语言虽然推崇使用Channel来解决对并发资源的访问，但同样实现了Sync.Mutex互斥锁供编程人员使用。本文就带领大家探索Sync.Mutex的实现。","image":["https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f31ab978043d4366901d32f5e648094d~tplv-k3u1fbpfcp-watermark.image"],"author":{"@type":"Organization","name":"烟花易冷DarkPrince"},"publisher":{"@type":"Organization","name":"掘金","logo":{"@type":"ImageObject","url":"//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/e08da34488b114bd4c665ba2fa520a31.svg"}},"datePublished":"2021-07-29T11:15:08+08:00","dateModified":"2021-07-30T14:17:25+08:00"},{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","name":"稀土掘金","position":1,"item":"https://juejin.cn"},{"@type":"ListItem","name":"后端","position":2,"item":"https://juejin.cn/backend"},{"@type":"ListItem","name":"文章","position":3}]}]</script><link rel="preload" href="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/fab0e9f.js" as="script"><link rel="preload" href="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/9c0af85.js" as="script"><link rel="preload" href="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/2eec92d.js" as="script"><link rel="preload" href="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/app.cf7c707.css" as="style"><link rel="preload" href="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/3421f55.js" as="script"><link rel="preload" href="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/layouts/default.58569e9.css" as="style"><link rel="preload" href="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/523d86f.js" as="script"><link rel="preload" href="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/60.a4f8cad.css" as="style"><link rel="preload" href="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/fd509fb.js" as="script"><link rel="preload" href="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/222.696c239.css" as="style"><link rel="preload" href="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/cdd39ba.js" as="script"><link rel="preload" href="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/103.9f93b63.css" as="style"><link rel="preload" href="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/fcf2e8d.js" as="script"><link rel="preload" href="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/215.8de3951.css" as="style"><link rel="preload" href="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/254af3e.js" as="script"><link rel="preload" href="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/218.adcadde.css" as="style"><link rel="preload" href="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/f6c285a.js" as="script"><link rel="stylesheet" href="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/app.cf7c707.css"><link rel="stylesheet" href="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/layouts/default.58569e9.css"><link rel="stylesheet" href="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/60.a4f8cad.css"><link rel="stylesheet" href="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/222.696c239.css"><link rel="stylesheet" href="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/103.9f93b63.css"><link rel="stylesheet" href="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/215.8de3951.css"><link rel="stylesheet" href="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/218.adcadde.css">
  </head>
  <body >
    <div data-server-rendered="true" id="__nuxt"><div id="__layout"><div id="juejin"><!----> <div class="view-container" data-v-1e8be6f4 data-v-8e24b4d2><div class="main-header-box" data-v-1e8be6f4><header data-fetch-key="0" class="main-header main-header unauthorized visible" data-v-25e3b163 data-v-1e8be6f4><div class="container" data-v-25e3b163><a href="/" class="logo" data-v-25e3b163><img src="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/e08da34488b114bd4c665ba2fa520a31.svg" alt="稀土掘金" class="logo-img" data-v-25e3b163> <img src="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/6c61ae65d1c41ae8221a670fa32d05aa.svg" alt="稀土掘金" class="mobile" data-v-25e3b163></a> <!----> <!----> <nav role="navigation" class="main-nav" data-v-25e3b163><ul class="nav-list" data-v-25e3b163><!----> <li class="main-nav-list" data-v-25e3b163><div class="phone-show-menu isResourceVisible" data-v-25e3b163><span data-v-25e3b163>首页</span> <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg" class="unfold16-icon" data-v-25e3b163 data-v-25e3b163><path d="M2.45025 4.82431C2.17422 4.49957 2.40501 4.00049 2.83122 4.00049H9.16878C9.59498 4.00049 9.82578 4.49957 9.54975 4.82431L6.38097 8.55229C6.1813 8.78719 5.8187 8.78719 5.61903 8.55229L2.45025 4.82431Z" data-v-25e3b163 data-v-25e3b163></path></svg></div> <ul class="phone-hide isResourceVisible" data-v-25e3b163><li class="nav-item link-item route-active" data-v-25e3b163><a href="/" data-v-25e3b163>首页</a></li> <li class="nav-item link-item activities" data-v-25e3b163><a href="/pins" data-v-25e3b163><span class="text" data-v-25e3b163>
                  沸点
                  <!----></span></a></li> <li class="nav-item link-item book" data-v-25e3b163><a href="/course" data-v-25e3b163>
                课程
                <!----></a></li> <li class="nav-item link-item" data-v-25e3b163><a href="/live" data-v-25e3b163>直播</a></li> <li class="nav-item link-item" data-v-25e3b163><a href="/events/all" data-v-25e3b163>活动</a></li> <li class="nav-item link-item" data-v-25e3b163><a href="/challenge" data-v-25e3b163>
                竞赛
                <!----></a></li> <nav class="nav-item link-item" data-v-25e3b163><a href="https://detail.youzan.com/show/goods/newest?kdt_id=104340304" target="_blank" rel="nofollow noopener noreferrer" class="nav-item link-item no-border" data-v-25e3b163><span data-v-25e3b163>商城</span></a> <!----></nav> <nav class="nav-item link-item download-icon isResourceVisible" data-v-25e3b163><a href="/app?utm_source=jj_nav" target="_blank" class="download-app no-border" data-v-25e3b163>
                APP
              </a> <!----></nav> <nav class="nav-item link-item extension-icon" data-v-25e3b163><a href="https://juejin.cn/extension?utm_source=jj_nav" target="_blank" rel="nofollow noopener noreferrer" class="broswer-extension no-border isResourceVisible" data-v-25e3b163><span data-v-25e3b163>插件</span></a></nav> <li tag="li" class="nav-item link-item special-activity-item" data-v-25e3b163><a target="_blank" href="https://conf.juejin.cn/xdc2023/?utm_source=jjwebdhl" class="activity no-hover special-activity" data-v-25e3b163><!----></a></li></ul></li> <ul class="right-side-nav" data-v-25e3b163><li class="search-add" data-v-25e3b163><ul class="search-add-ul isResourceVisible" data-v-25e3b163><li class="nav-item search" data-v-25e3b163><form role="search" class="search-form isResourceVisible" data-v-25e3b163><input type="search" maxlength="64" placeholder="" value="" class="search-input isResourceVisible" data-v-25e3b163> <div class="seach-icon-container" data-v-25e3b163><svg width="18" height="18" viewBox="0 0 18 18" fill="none" xmlns="http://www.w3.org/2000/svg" class="search-icon" data-v-25e3b163 data-v-25e3b163><path d="M12.4008 12.4008C14.744 10.0577 14.744 6.25871 12.4008 3.91556C10.0577 1.57242 6.25871 1.57242 3.91556 3.91556C1.57242 6.25871 1.57242 10.0577 3.91556 12.4008C6.25871 14.744 10.0577 14.744 12.4008 12.4008ZM12.4008 12.4008L15.5828 15.5828" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" data-v-25e3b163 data-v-25e3b163></path></svg></div> <div class="typehead" style="display:none;" data-v-25e3b163><!----> <div class="title" data-v-25e3b163><span data-v-25e3b163>搜索历史</span> <span class="clear" data-v-25e3b163>
                        清空
                      </span></div> <div class="list" data-v-25e3b163></div></div></form></li> <li class="nav-item add creator-item" data-v-25e3b163><div class="add-group" data-v-9fa8ab8e data-v-25e3b163><!----> <button class="add-btn" data-v-9fa8ab8e>
    创作者中心
  </button> <div class="more" data-v-9fa8ab8e><svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg" class="unfold12-icon" data-v-9fa8ab8e data-v-9fa8ab8e><path d="M2.45025 4.82383C2.17422 4.49908 2.40501 4 2.83122 4H9.16878C9.59499 4 9.82578 4.49908 9.54975 4.82382L6.38097 8.5518C6.1813 8.7867 5.8187 8.7867 5.61903 8.5518L2.45025 4.82383Z" fill="white" data-v-9fa8ab8e data-v-9fa8ab8e></path></svg> <div class="more-mask" data-v-9fa8ab8e></div> <div class="more-list" data-v-9fa8ab8e><ul class="menu" data-v-9fa8ab8e><li class="item" data-v-9fa8ab8e><div class="icon write-article" data-v-9fa8ab8e></div> <div class="title" data-v-9fa8ab8e>写文章</div></li><li class="item" data-v-9fa8ab8e><div class="icon issue-points" data-v-9fa8ab8e></div> <div class="title" data-v-9fa8ab8e>发沸点</div></li><li class="item" data-v-9fa8ab8e><div class="icon write-note" data-v-9fa8ab8e></div> <div class="title" data-v-9fa8ab8e>写笔记</div></li><li class="item" data-v-9fa8ab8e><div class="icon create-jcode" data-v-9fa8ab8e></div> <div class="title" data-v-9fa8ab8e>写代码</div></li><li class="item" data-v-9fa8ab8e><div class="icon drafts" data-v-9fa8ab8e></div> <div class="title" data-v-9fa8ab8e>草稿箱</div></li></ul> <div class="divider" data-v-9fa8ab8e></div> <div class="inspiration" data-v-9fa8ab8e><div class="info" data-v-9fa8ab8e><span class="title" data-v-9fa8ab8e>创作灵感</span> <span class="more-info" data-v-9fa8ab8e>
            查看更多
            <i class="icon byte-icon byte-icon--right" data-v-9fa8ab8e><svg t="1561636167146" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="404349" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M630.4 512L283.52 165.12a21.12 21.12 0 0 1 0-30.08l30.08-30.08a21.12 21.12 0 0 1 30.08 0l377.6 376.96a42.24 42.24 0 0 1 0 60.16l-377.6 376.96a21.12 21.12 0 0 1-30.08 0l-30.08-30.08a21.12 21.12 0 0 1 0-30.08z" p-id="404350"></path></svg></i></span></div> <div class="list" data-v-9fa8ab8e>  <div class="item" data-v-3ff8f708 data-v-9fa8ab8e><div class="xitu-skeleton xitu-skeleton-animated" data-v-3ff8f708><div class="xitu-skeleton-item" data-v-3ff8f708><!----> <div class="xitu-skeleton-content" data-v-3ff8f708><div class="xitu-skeleton-line" data-v-3ff8f708></div><div class="xitu-skeleton-line" data-v-3ff8f708></div><div class="xitu-skeleton-line" data-v-3ff8f708></div></div></div></div></div></div></div></div></div> <!----></div></li></ul></li> <!----> <li class="nav-item vip-entry" data-v-25e3b163><div class="vip-title" data-v-25e3b163><div class="vip-entry-img" data-v-25e3b163><img src="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/24127194d5b158d7eaf8f09a256c5d01.svg" alt="vip" class="vip-img" data-v-25e3b163> <!----></div> <div class="vip-words" data-v-25e3b163>会员</div></div></li> <!----> <!----> <!----> <li class="nav-item auth" data-v-25e3b163><div class="login-button-wrap" data-v-25e3b163><button class="login-button" data-v-25e3b163>
                登录
                <!----></button> <!----></div></li></ul></ul></nav></div> <!----></header></div>  <main class="container main-container" style="max-width:1140px;" data-v-1e8be6f4><div class="view column-view" data-v-1e8be6f4 data-v-8e24b4d2><div class="main-area article-area" data-v-1e8be6f4 data-v-8e24b4d2><article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="6990181431574003726" data-draft-id="6979922906226638885" data-original-type="0" class="article" data-v-8e24b4d2><!----> <meta itemprop="headline" content="【Go源码剖析】解读精益求精的 Sync.Mutex"> <meta itemprop="keywords" content="Go,源码"> <meta itemprop="datePublished" content="2021-07-29T03:15:08.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="烟花易冷DarkPrince"> <meta itemprop="url" content="https://juejin.cn/user/2101921964623992"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-8e24b4d2>
            【Go源码剖析】解读精益求精的 Sync.Mutex
            <!----></h1> <div class="author-info-block" data-v-8e24b4d2><a href="/user/2101921964623992" target="_blank" rel="" class="avatar-link" data-v-8e24b4d2><img loading="eager" src="https://p3-passport.byteimg.com/img/user-avatar/ce5ce2f18b2ab595a782ac86c8883f9b~100x100.image" alt="" class="lazy avatar avatar" data-v-55b483d2 data-v-0b45085c data-v-8e24b4d2></a> <div class="author-info-box" data-v-8e24b4d2><div class="author-name" data-v-8e24b4d2><a href="/user/2101921964623992" target="_blank" rel="" class="username username ellipsis" data-v-2b2ca9ee data-v-8e24b4d2><span class="name" style="max-width:128px;" data-v-2b2ca9ee>
    烟花易冷DarkPrince
  </span> <span blank="true" class="rank" data-v-19095f0c data-v-2b2ca9ee><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8AQMAAAAAMksxAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAA5JREFUKM9jGAWjAAcAAAIcAAE27nY6AAAAAElFTkSuQmCC" alt="创作等级LV.4" title="创作等级LV.4" class="lazy" style="aspect-ratio:NaN;" data-v-55b483d2 data-v-19095f0c></span> <!----> <!----> </a> <!----></div> <div class="meta-box" data-v-8e24b4d2><time datetime="2021-07-29T03:15:08.000Z" title="Thu Jul 29 2021 11:15:08 GMT+0800 (China Standard Time)" class="time" data-v-8e24b4d2>
                    2021年07月29日 11:15
                  </time> <span class="views-count" style="display:none;" data-v-8e24b4d2>
                    ·  阅读
                    3831
                  </span> <!----></div></div> <!----></div> <!----> <img loading="eager" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f31ab978043d4366901d32f5e648094d~tplv-k3u1fbpfcp-zoom-crop-mark:1512:1512:1512:851.image" alt="【Go源码剖析】解读精益求精的 Sync.Mutex" class="lazy article-hero" data-v-55b483d2 data-v-8e24b4d2> <!----> <!----> <div itemprop="articleBody" class="article-content" data-v-8e24b4d2><div class="markdown-body cache html"><html><head><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre>code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style></head><body><p>“互斥锁”对于并发编程是必不可少的，Go语言虽然推崇使用Channel来解决对并发资源的访问，但同样实现了Sync.Mutex互斥锁供编程人员使用。有人做过专门的统计，在知名的开源软件Docker、Kubernutes、etcd、gRPC中，使用Mutex的频率是最高的。Go语言随着版本的迭代，对Sync.Mutex的实现也愈发精细化，当前版本的Sync.Mutex核心实现代码已经有100多行，其中大量使用了复杂位运算和流程控制来解决各种问题，因此使得Sync.Mutex源码达到了不可读的状态，本文从历史发展的角度剖析Sync.Mutex，希望能帮助读者读懂Sync.Mutex的源码并掌握其设计思想。</p>
<h2 data-id="heading-0">1. 初版互斥锁——先到先得</h2>
<p>github地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgolang%2Fgo%2Fblob%2Frelease.r56%2Fsrc%2Fpkg%2Fsync%2Fmutex.go" target="_blank" title="https://github.com/golang/go/blob/release.r56/src/pkg/sync/mutex.go" ref="nofollow noopener noreferrer">初级版本的互斥锁</a></p>
<p>代码量很少，我们来分析一下：</p>
<pre><code class="hljs language-go copyable" lang="go"><span class="hljs-keyword">package</span> sync

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"runtime"</span>
    <span class="hljs-string">"sync/atomic"</span>
)


<span class="hljs-comment">//互斥锁结构</span>
<span class="hljs-keyword">type</span> Mutex <span class="hljs-keyword">struct</span> {
    key  <span class="hljs-type">int32</span>
    sema <span class="hljs-type">uint32</span>
}

<span class="hljs-comment">//请求锁</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> Lock() {
    <span class="hljs-keyword">if</span> atomic.AddInt32(&#x26;m.key, <span class="hljs-number">1</span>) == <span class="hljs-number">1</span> {    <span class="hljs-comment">//标识加1，如果等于1，成功获取到锁</span>
        <span class="hljs-keyword">return</span>
    }
    runtime.Semacquire(&#x26;m.sema)     <span class="hljs-comment">//否则阻塞等待</span>
}


<span class="hljs-comment">//释放锁</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> Unlock() {
    <span class="hljs-keyword">switch</span> v := atomic.AddInt32(&#x26;m.key, <span class="hljs-number">-1</span>); {  <span class="hljs-comment">//标识减1</span>
    <span class="hljs-keyword">case</span> v == <span class="hljs-number">0</span>:    <span class="hljs-comment">//如果等于0，则没有等待者</span>
        <span class="hljs-keyword">return</span>
    <span class="hljs-keyword">case</span> v == <span class="hljs-number">-1</span>:   <span class="hljs-comment">//如果等于-1，这种是异常情况，或者超过了最大可等待goroutine的数量</span>
        <span class="hljs-built_in">panic</span>(<span class="hljs-string">"sync: unlock of unlocked mutex"</span>)
    }
    runtime.Semrelease(&#x26;m.sema) <span class="hljs-comment">//唤醒其他阻塞的goroutine</span>
}
<span class="copy-code-btn">复制代码</span></code></pre>
<p>初级版本的Mutex包含两个字段：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a73d27373684cefa3c1ae3448342999~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" alt="初版Mutex.png" loading="lazy"></p>
<p>当goroutine调用Lock方法请求锁的时候，通过atomic.AddInt32方法原子性的给key加1，如果比较幸运，当前没有等待者，那么key的值就会等于1，成功获取到锁；如果锁已经被别的 goroutine 持有了，当前的 goroutine 会在将 key 加 1的同时，调用 runtime.Semacquire 方法，使用信号量将自己休眠，等锁释放的时候，信号量会将它唤醒。释放锁的操作也比较简单，就是原子性的给key减1，不过当减1之后值变成-1的时候，程序就会panic，例如没有请求锁，直接对锁进行释放就会panic这个错误；此外还有一种情况，<strong>Mutex结构中的key是一个int32类型，它能表达的最大整数是40多亿，当争抢锁的goroutine数目达到这个阈值的时候，也会panic，但是这种情况在服务器资源有限的情况下，是不可能会发生的。</strong></p>
<p>我们先来探讨两个问题：</p>
<ul>
<li>为什么请求锁时，需要使用原子操作？</li>
<li>为什么需要信号量？它的实现机制是什么？</li>
</ul>
<h3 data-id="heading-1">1.1 原子操作的必要性</h3>
<p>我们先来看一个简单技术器程序 counter.go。</p>
<pre><code class="hljs language-go copyable" lang="go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
   <span class="hljs-string">"fmt"</span>
   <span class="hljs-string">"sync"</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
   <span class="hljs-comment">//runtime.GOMAXPROCS(1)</span>
   <span class="hljs-keyword">var</span> counter <span class="hljs-type">int64</span>
   <span class="hljs-keyword">var</span> wg sync.WaitGroup
   wg.Add(<span class="hljs-number">2</span>)
   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &#x3C; <span class="hljs-number">2</span>; i++ {
      <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {
         <span class="hljs-keyword">defer</span> wg.Done()
         <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &#x3C; <span class="hljs-number">10000</span>; j++ {
            counter++  <span class="hljs-comment">//atomic.AddInt64(&#x26;counter, 1)</span>
         }
      }()
   }
   wg.Wait()
   fmt.Println(counter)
}
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们启动2个goroutine并发的累加counter，每个goroutine将counter累加1万，运行程序大概率打印出来的counter值不会是2万，而是一个小于2万的数，每次运行结果都不一样。熟悉并发编程的读者应该早都看出了端倪，这段程序中存在竞态条件。counter++不是一个原子操作，它包含三个步骤：1.读取counter变量当前值；2.对counter当前值加1，保存到寄存器临时变量中；3.将临时变量的结果再保存到counter中。其中的每一个步骤，都有对应的汇编实现。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a61ee5a4e61b40c88532bcb7baa8f523~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" alt="竞态goroutine.png" loading="lazy"></p>
<p>当我们使用一个CPU核心的时候(使用runtime.GOMAXPROCS(1)设置)，多次运行程序，似乎我们总能得到2万的准确计数，但是这并不是一个强保证，当我们使用<code>go run -race counter.go</code>竞态检测就大概率能检测到这段程序对counter变量的内存有非同步的并发读写：</p>
<pre><code class="hljs language-bash copyable" lang="bash">==================
WARNING: DATA RACE
Read at 0x00c000136008 by goroutine 8:
  main.main.func1()
      /Users/guozhaoran/goCode/basic/goConcurrent/mutex/example.go:17 +0x78

Previous write at 0x00c000136008 by goroutine 7:
  main.main.func1()
      /Users/guozhaoran/goCode/basic/goConcurrent/mutex/example.go:17 +0x91

Goroutine 8 (running) created at:
  main.main()
      /Users/guozhaoran/goCode/basic/goConcurrent/mutex/example.go:14 +0xe4

Goroutine 7 (finished) created at:
  main.main()
      /Users/guozhaoran/goCode/basic/goConcurrent/mutex/example.go:14 +0xe4
==================
<span class="copy-code-btn">复制代码</span></code></pre>
<p>所以解决方案就是使用atomic包，它非常适合于这种全局单体变量的原子性加减，而这种原子性的实现是不同的CPU架构硬件提供的能力，通过LOCK汇编指令锁定数据总线来完成。<strong>对于Mutex的应用场景，原子操作当然是必不可少的，它保证了多个goroutine对共享变量key累加的一致性</strong>。</p>
<h3 data-id="heading-2">1.2 信号量</h3>
<p>信号量的概念是荷兰计算机科学家 Edsger Dijkstra 在 1963 年左右提出来的，广泛应用在不同的操作系统中。在系统中，会给每一个进程一个信号量，代表每个进程目前的状态。未得到控制权的进程，会在特定的地方被迫停下来，等待可以继续进行的信号到来。</p>
<p>Dijkstra 在他的论文中为信号量定义了两个操作 P 和 V。P 操作（descrease、wait、acquire）是减少信号量的计数值，而 V 操作（increase、signal、release）是增加信号量的计数值。使用伪代码表示如下（中括号代表原子操作）：</p>
<pre><code class="hljs language-lua copyable" lang="lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">V</span><span class="hljs-params">(semaphore S, integer I)</span></span>: 
    [S ← S + I]

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">P</span><span class="hljs-params">(semaphore S, integer I)</span></span>: 
    <span class="hljs-keyword">repeat</span>: 
        [<span class="hljs-keyword">if</span> S ≥ I: 
        S ← S − I 
        <span class="hljs-keyword">break</span>]
<span class="copy-code-btn">复制代码</span></code></pre>
<p>可以看到，初始化信号量 S 有一个指定数量（n）的资源，它就像是一个有 n 个资源的池子。P 操作相当于请求资源，如果资源可用，就立即返回；如果没有资源或者不够，那么，它可以不断尝试或者阻塞等待。V 操作会释放自己持有的资源，把资源返还给信号量。信号量的值除了初始化的操作以外，只能由 P/V 操作改变。</p>
<p>现在，我们来总结下信号量的实现。初始化信号量：</p>
<ul>
<li>设定初始的资源的数量。</li>
<li>P 操作：将信号量的计数值减去 1，<strong>如果新值已经为负，那么调用者会被阻塞并加入到等待队列中</strong>。否则，调用者会继续执行，并且获得一个资源。</li>
<li>V 操作：将信号量的计数值加 1，如果先前的计数值为负，就说明有等待的 P 操作的调用者。它会从等待队列中取出一个等待的调用者，唤醒它，让它继续执行。</li>
</ul>
<p>在运行时，Go 内部使用信号量来控制 goroutine 的阻塞和唤醒。比如互斥锁的第二个字段sema，信号量的 P/V 操作是通过函数实现的(Go内部运行时的信号量也是通过atomic和gopark实现的，具体实现可以看runtime/sema.go)。</p>
<pre><code class="hljs language-go copyable" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runtime_Semacquire</span><span class="hljs-params">(s *<span class="hljs-type">uint32</span>)</span></span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runtime_SemacquireMutex</span><span class="hljs-params">(s *<span class="hljs-type">uint32</span>, lifo <span class="hljs-type">bool</span>, skipframes <span class="hljs-type">int</span>)</span></span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runtime_Semrelease</span><span class="hljs-params">(s *<span class="hljs-type">uint32</span>, handoff <span class="hljs-type">bool</span>, skipframes <span class="hljs-type">int</span>)</span></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>值得一提的是，<strong>Go运行时的信号量实现的是一个优先级等待队列，这也是当前阶段Mutex饥饿模式实现的基础</strong>。信号量的 P/V 操作函数，可以将goroutine休眠后添加到优先级队列的头部或尾部；也可以从优先级队列的头部或尾部将goroutine取出唤醒。</p>
<h2 data-id="heading-3">2. 互斥锁初步优化——给要抢锁的goroutine一次机会</h2>
<p>解读完初版互斥锁的实现，读者可能会发现一个问题，当锁被持有的情况下，新到来争抢锁的goroutine直接被运行时的信号量休眠并添加到了优先队列中，虽然这样严格保证了锁争抢的先来先得顺序，但是goroutine的休眠和唤醒非常影响性能，针对这一点，Go开发者对Mutex做了一次大的调整。</p>
<p>github地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgolang%2Fgo%2Fblob%2Fweekly.2011-07-07%2Fsrc%2Fpkg%2Fsync%2Fmutex.go" target="_blank" title="https://github.com/golang/go/blob/weekly.2011-07-07/src/pkg/sync/mutex.go" ref="nofollow noopener noreferrer">互斥锁进一步优化</a></p>
<p>此时的Mutex结构如下:</p>
<pre><code class="hljs language-go copyable" lang="go"><span class="hljs-keyword">type</span> Mutex <span class="hljs-keyword">struct</span> {
    state <span class="hljs-type">int32</span>
    sema  <span class="hljs-type">uint32</span>
}

<span class="hljs-keyword">const</span> (
    mutexLocked = <span class="hljs-number">1</span> &#x3C;&#x3C; <span class="hljs-literal">iota</span> <span class="hljs-comment">// mutex is locked</span>
    mutexWoken
    mutexWaiterShift = <span class="hljs-literal">iota</span>
)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>Mutex结构体的key被改成了state，代表的含义也被拆分成了三个。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/349de742eca64696ae55e8cb210f20ca~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" alt="第一版优化后的Mutex.png" loading="lazy"></p>
<ul>
<li>MutexLocked：state的第一个位代表锁是否被持有</li>
<li>MutexWoken：state的第二个位代表是否有唤醒的 goroutine</li>
<li>MutexWaiters：state剩下的位代表的是等待此锁的 goroutine 数</li>
</ul>
<p>在分析这个版本的代码之前，我们先来补充一个要用到的非常重要的知识点：CAS。</p>
<h3 data-id="heading-4">2.1 自旋锁(CAS)及其实现原理</h3>
<p>CAS指令的实现原理是将给定的值与内存中的值进行比较，如果是同一个值，就用新值替换掉内存中的值，然后返回。如果不是就返回第一步的比较，因此得名“自旋锁”。下面画一个图来描述一下CAS算法，并和Go语言中的atomic.CompareAndSwap函数簇做一个比较：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56df16fd67fe4e2782577c5abc3fd59d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" alt="CAS工作原理图.png" loading="lazy"></p>
<p>有一点需要特别注意，<strong>CAS中值的比较与交换过程是原子性的，这个过程中如果有其他的goroutine修改了内存中的值，那么CAS会返回false</strong>。</p>
<p>CAS也是Mutex实现的基础，读者可能会有疑问：有了CAS为什么还要有信号量呢？<strong>其实无论是原子操作，还是自旋锁，都不适合长时间等待的情况，因为有很多资源（数据）它有一定的时间性，你想去获取它，CPU 并不能立即返回给你，而是要等待一段时间，才能把数据返回给你。这种情况，你用自旋锁来同步访问这种资源，你会发现这是对 CPU 时间的巨大浪费。当然Mutex的实现非常适合使用CAS</strong>。</p>
<h3 data-id="heading-5">2.2 互斥锁初步优化后的Lock实现</h3>
<p>介绍完了CAS，我们来看当前版本的Lock实现，直接上代码：</p>
<pre><code class="hljs language-go copyable" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> Lock() {
    <span class="hljs-comment">// Fast path: 幸运case，能够直接获取到锁</span>
    <span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&#x26;m.state, <span class="hljs-number">0</span>, mutexLocked) {
        <span class="hljs-keyword">return</span>
    }

    awoke := <span class="hljs-literal">false</span>
    <span class="hljs-keyword">for</span> {
        old := m.state
        <span class="hljs-built_in">new</span> := old | mutexLocked    <span class="hljs-comment">//新状态加锁</span>
        <span class="hljs-keyword">if</span> old&#x26;mutexLocked != <span class="hljs-number">0</span> {
            <span class="hljs-built_in">new</span> = old + <span class="hljs-number">1</span>&#x3C;&#x3C;mutexWaiterShift     <span class="hljs-comment">//等待者数量加一</span>
        }
        <span class="hljs-keyword">if</span> awoke {
            <span class="hljs-comment">//goroutine是被唤醒的，新状态清除唤醒标记</span>
            <span class="hljs-built_in">new</span> &#x26;^= mutexWoken
        }
        <span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&#x26;m.state, old, <span class="hljs-built_in">new</span>) { <span class="hljs-comment">//设置新状态</span>
            <span class="hljs-keyword">if</span> old&#x26;mutexLocked == <span class="hljs-number">0</span> {   <span class="hljs-comment">//锁原状态未加锁</span>
                <span class="hljs-keyword">break</span>
            }
            runtime.Semacquire(&#x26;m.sema)  <span class="hljs-comment">//请求信号量</span>
            awoke = <span class="hljs-literal">true</span> <span class="hljs-comment">//设置唤醒标记</span>
        }
    }
}
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们重点看一下对state的操作。首先通过CAS检测Mutex是否没有被goroutine持有并且没有等待者，如果是这样，那么当前goroutine很幸运，可以直接获取到锁，这也就是代码中标注的Fast path。</p>
<p>如果当前goroutine不够幸运，那么会走到下边的循环检查阶段，for 循环不断尝试获取锁，如果获取不到，就通过 runtime.Semacquire(&#x26;m.sema) 休眠，休眠醒来之后 awoke 置为 true，尝试争抢锁。我们知道state有三个含义：</p>
<ul>
<li>通过<code>new := old | mutexLocked</code>设置state中的mutexLocked，给Mutex加锁；</li>
<li>通过<code>new = old + 1&#x3C;&#x3C;mutexWaiterShift</code>给Mutex设置mutexWaiterShift，等待者加1；</li>
<li>通过<code>new &#x26;^= mutexWoken</code>给Mutex清除Mutex的唤醒标记。</li>
</ul>
<p>那么接下来<code>atomic.CompareAndSwapInt32(&#x26;m.state, old, new)</code>执行成功说明给state设置了新值，就要区分两种情况考虑了，第一种情况是state新值中包含加锁成功了，那么直接break，goroutine抢到了锁，程序结束；否则只能说明state 只是清除 mutexWoken 标志或者增加一个 waiter 而已。</p>
<p>这里的循环状态检查的代码有两种goroutine会同时执行：</p>
<ul>
<li>新来抢锁的goroutine(可能有多个)</li>
<li>从信号量优先队列中唤醒的goroutine(最多只可能有一个)</li>
</ul>
<p>上边的描述可能比较抽象，我们结合下边的流程图帮助理解一下吧：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26c0382433b84652a559a2dcb8201c82~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" alt="互斥锁争抢的原理.png" loading="lazy"></p>
<h3 data-id="heading-6">2.3 互斥锁初步优化后的Unlock实现</h3>
<p>Unlock方法也变得复杂了，但是不像Lock，仔细研究一下，还是能看得懂的，下边是代码：</p>
<pre><code class="hljs language-go copyable" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> Unlock() {
    <span class="hljs-comment">// Fast path: drop lock bit.</span>
    <span class="hljs-built_in">new</span> := atomic.AddInt32(&#x26;m.state, -mutexLocked)  <span class="hljs-comment">//去掉锁状态</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">new</span>+mutexLocked)&#x26;mutexLocked == <span class="hljs-number">0</span> {     <span class="hljs-comment">//未被锁定的mutex释放锁会panic</span>
        <span class="hljs-built_in">panic</span>(<span class="hljs-string">"sync: unlock of unlocked mutex"</span>)
    }

    old := <span class="hljs-built_in">new</span>
    <span class="hljs-keyword">for</span> {
        <span class="hljs-comment">//锁上没有goroutine等待或者有被唤醒的goroutine,或者又被别的goroutine加了锁,那么不需要做任何事情，返回即可</span>
        <span class="hljs-keyword">if</span> old>>mutexWaiterShift == <span class="hljs-number">0</span> || old&#x26;(mutexLocked|mutexWoken) != <span class="hljs-number">0</span> {
            <span class="hljs-keyword">return</span>
        }
        <span class="hljs-comment">//将mutexWaiterShift数量减1并设置mutexWoken为true</span>
        <span class="hljs-built_in">new</span> = (old - <span class="hljs-number">1</span>&#x3C;&#x3C;mutexWaiterShift) | mutexWoken
        <span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&#x26;m.state, old, <span class="hljs-built_in">new</span>) {     <span class="hljs-comment">//CAS设置成功，唤醒一个新的goroutine争抢锁即可</span>
            runtime.Semrelease(&#x26;m.sema)
            <span class="hljs-keyword">return</span>
        }
        old = m.state   <span class="hljs-comment">//记录当前mutex的状态，继续循环</span>
    }
}
<span class="copy-code-btn">复制代码</span></code></pre>
<p>Unlock方法先定义一个新变量将锁标志去掉，如果对一个未加锁的Mutex进行Unlock会panic，然后程序还需要进行一些额外的判断，并不能直接返回。下面情况之一调用Unlock的goroutine可以直接返回：</p>
<ul>
<li>Mutex上没有waiter</li>
<li>Mutex又被别人上了锁</li>
<li>有goroutine被唤醒了</li>
</ul>
<p>否则，先设置Mutex中mutexWaiterShift减1，并标记mutexWoken为true，使用CAS方法如果设置成功，则从信号量的优先队列中唤醒一个goroutine，程序返回。否则记录当前mutex的状态，继续循环判断。直到返回为止。</p>
<p>相比较最初版本的设计，这个版本的Sync.Mutex实现主要是给新来的goroutine一次获取到锁的机会，打破了原来先来先得的逻辑，代码的复杂度也增加了不少。</p>
<h2 data-id="heading-7">3. 互斥锁进一步优化——给要抢锁的goroutine更多机会</h2>
<p>我们前边对Sync.Mutex的优化是基于一种猜想：新来的争抢锁的goroutine很大概率上能够获取到锁！持有锁的goroutine在持有锁时间越短的情况下，这种概率越大，那么我们为什么不给争抢锁的goroutine更多机会呢？也就是让它们稍微等一会，如果等一会也获取不到，那么就乖乖的添加进信号量的优先队列就好了。实际上，Go官方团队也是这么做的。</p>
<p>gihub地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgolang%2Fgo%2Fblob%2Fgo1.5%2Fsrc%2Fsync%2Fmutex.go" target="_blank" title="https://github.com/golang/go/blob/go1.5/src/sync/mutex.go" ref="nofollow noopener noreferrer">给要抢锁的goroutine更多机会</a></p>
<p>我们来看一下代码：</p>
<pre><code class="hljs language-go copyable" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> Lock() {
    <span class="hljs-comment">// Fast path: 幸运case，能够直接获取到锁</span>
    <span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&#x26;m.state, <span class="hljs-number">0</span>, mutexLocked) {
        <span class="hljs-keyword">return</span>
    }

    awoke := <span class="hljs-literal">false</span>
    iter := <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> {   <span class="hljs-comment">// 不管是新来的请求锁的goroutine, 还是被唤醒的goroutine，都不断尝试请求锁</span>
        old := m.state
        <span class="hljs-built_in">new</span> := old | mutexLocked    <span class="hljs-comment">//新状态加锁</span>
        <span class="hljs-keyword">if</span> old&#x26;mutexLocked != <span class="hljs-number">0</span> {   <span class="hljs-comment">// 锁还没被释放</span>
            <span class="hljs-keyword">if</span> runtime_canSpin(iter) {  <span class="hljs-comment">// 还可以自旋</span>
                <span class="hljs-keyword">if</span> !awoke &#x26;&#x26; old&#x26;mutexWoken == <span class="hljs-number">0</span> &#x26;&#x26; old>>mutexWaiterShift != <span class="hljs-number">0</span> &#x26;&#x26;
                    atomic.CompareAndSwapInt32(&#x26;m.state, old, old|mutexWoken) {
                    awoke = <span class="hljs-literal">true</span>
                }
                runtime_doSpin()
                iter++
                <span class="hljs-keyword">continue</span>    <span class="hljs-comment">//自旋，再次尝试获取锁</span>
            }
            <span class="hljs-built_in">new</span> = old + <span class="hljs-number">1</span>&#x3C;&#x3C;mutexWaiterShift      <span class="hljs-comment">//等待者数量加一</span>
        }
        <span class="hljs-keyword">if</span> awoke {  <span class="hljs-comment">//唤醒状态，去掉标记</span>
            <span class="hljs-built_in">new</span> &#x26;^= mutexWoken
        }
        <span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&#x26;m.state, old, <span class="hljs-built_in">new</span>) { <span class="hljs-comment">//设置新状态</span>
            <span class="hljs-keyword">if</span> old&#x26;mutexLocked == <span class="hljs-number">0</span> {   <span class="hljs-comment">//锁原状态未加锁</span>
                <span class="hljs-keyword">break</span>
            }
            runtime_Semacquire(&#x26;m.sema) <span class="hljs-comment">//请求信号量</span>
            awoke = <span class="hljs-literal">true</span>    <span class="hljs-comment">//设置信号量</span>
            iter = <span class="hljs-number">0</span>    <span class="hljs-comment">//重新设置自旋计数器</span>
        }
    }
}
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这次的优化很小，只增加了runtime_canSpin的检测，有一个自旋计数器iter，如果抢锁的goroutine还能自旋的话，就自旋等待持有锁的goroutine释放锁，这样能够增大抢到锁的概率。</p>
<p>我想读者应该对代码中的这部分很迷惑：</p>
<pre><code class="hljs language-ini copyable" lang="ini">if !awoke &#x26;&#x26; old&#x26;<span class="hljs-attr">mutexWoken</span> == <span class="hljs-number">0</span> &#x26;&#x26; old>>mutexWaiterShift != <span class="hljs-number">0</span> &#x26;&#x26;
                    atomic.CompareAndSwapInt32(&#x26;m.state, old, old|mutexWoken) {
                    <span class="hljs-attr">awoke</span> = <span class="hljs-literal">true</span>
                }
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这四个&#x26;&#x26;符号确实让人眼花撩乱，不过结合上一小节对Sync.Mutex的解读，我们能分析出这段代码的用途。首先&#x26;&#x26;是短路运算符，有一个为false判断就不会进行下去了。<code>!awoke</code>表示程序逻辑是由新加入抢锁的goroutine进来的，而不是从sema优先级队列中唤醒的goroutine进来的；再然后如果Mutex的旧值是没有唤醒新的goroutine(<code>old&#x26;mutexWoken == 0</code>)的并且有等待者(<code>old>>mutexWaiterShift != 0</code>)的话，就尝试通过CAS给Mutex设置一个唤醒标记(<code>atomic.CompareAndSwapInt32(&#x26;m.state, old, old|mutexWoken)</code>)，如果成功的话，将awoke设置为true，这样做可以让调用Unlock的goroutine快速返回，而不用从优先队列中再唤醒goroutine来争抢锁。</p>
<p>经过这一版本的优化，我们可以看到，<strong>Sync.Mutex对新加入抢锁的goroutine相当友好，表面上看这样似乎没有什么问题，能够让更多的goroutine在最短的时间内获取到锁。但是我们考虑一下那些一直在信号量优先队列中的等待者怎么办？锁有可能一直被新来的goroutine抢到，这就产生了“饥饿问题”</strong>。</p>
<h2 data-id="heading-8">4.终极版本的互斥锁——小康社会，不再饥饿</h2>
<p>Sync.Mutex的“饥饿问题”早在Go 1.9版本中就解决了，后续也进行了一些优化工作，到此Sync.Mutex才算是实现的比较完美。我们接下来会解读当前最新版本Go1.17的代码实现，读者要和我一起开启烧脑模式，细细的品一品了。</p>
<p>github地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgolang%2Fgo%2Fblob%2Fgo1.17rc1%2Fsrc%2Fsync%2Fmutex.go" target="_blank" title="https://github.com/golang/go/blob/go1.17rc1/src/sync/mutex.go" ref="nofollow noopener noreferrer">终极版本的Sync.Mutex</a></p>
<h3 data-id="heading-9">4.1 Mutex结构体实现</h3>
<p>为了解决饥饿问题，Mutex结构体从state字段中又分出一个位标识当前Mutex是否饥饿，并定义了一个常量，将获取锁的goroutine等待时间设置了 1 毫秒阈值。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aac838c01ab04e3792b29c4736435b23~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" alt="终极版本的Mutex.png" loading="lazy"></p>
<pre><code class="hljs language-go copyable" lang="go"><span class="hljs-keyword">type</span> Mutex <span class="hljs-keyword">struct</span> {
    state <span class="hljs-type">int32</span>
    sema  <span class="hljs-type">uint32</span>
}

<span class="hljs-keyword">const</span> (
    mutexLocked = <span class="hljs-number">1</span> &#x3C;&#x3C; <span class="hljs-literal">iota</span> <span class="hljs-comment">// mutex is locked</span>
    mutexWoken
    mutexStarving   <span class="hljs-comment">// 从state字段中分出一个饥饿标记</span>
    mutexWaiterShift = <span class="hljs-literal">iota</span>

    starvationThresholdNs = <span class="hljs-number">1e6</span>   <span class="hljs-comment">//1000000ns = 1ms</span>
)
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-10">4.2 Sync.Mutex 终极版本的Lock函数实现</h3>
<p>最新版本的Sync.Mutex的Lock方法和Unlock方法将fast path 和slow path拆成独立的函数，以便内联，提高性能。本节我们先来看一下Lock方法的实现：</p>
<pre><code class="hljs language-go copyable" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> Lock() {
	<span class="hljs-comment">// Fast path: 顺利的获取到锁</span>
	<span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&#x26;m.state, <span class="hljs-number">0</span>, mutexLocked) {
		<span class="hljs-keyword">if</span> race.Enabled {
			race.Acquire(unsafe.Pointer(m))
		}
		<span class="hljs-keyword">return</span>
	}
	<span class="hljs-comment">// Slow path (缓慢之路，通过自旋、竞争或者饥饿状态下的锁竞争)</span>
	m.lockSlow()
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> lockSlow() {
	<span class="hljs-keyword">var</span> waitStartTime <span class="hljs-type">int64</span>
	starving := <span class="hljs-literal">false</span>       <span class="hljs-comment">//标识当前goroutine是否饥饿</span>
	awoke := <span class="hljs-literal">false</span>  <span class="hljs-comment">//唤醒标记</span>
	iter := <span class="hljs-number">0</span>   <span class="hljs-comment">//自旋次数</span>
	old := m.state  <span class="hljs-comment">//当前的锁状态</span>
	<span class="hljs-keyword">for</span> {
		<span class="hljs-comment">//锁是非饥饿状态，并且未释放，尝试自旋</span>
		<span class="hljs-keyword">if</span> old&#x26;(mutexLocked|mutexStarving) == mutexLocked &#x26;&#x26; runtime_canSpin(iter) {
			<span class="hljs-comment">// 主动自旋的场景</span>
			<span class="hljs-comment">// 尝试设置 mutexWoken 标志以通知 Unlock 不唤醒其他阻塞的 goroutine</span>
			<span class="hljs-keyword">if</span> !awoke &#x26;&#x26; old&#x26;mutexWoken == <span class="hljs-number">0</span> &#x26;&#x26; old>>mutexWaiterShift != <span class="hljs-number">0</span> &#x26;&#x26;
				atomic.CompareAndSwapInt32(&#x26;m.state, old, old|mutexWoken) {
				awoke = <span class="hljs-literal">true</span>
			}
			runtime_doSpin()    <span class="hljs-comment">//自旋</span>
			iter++
			old = m.state
			<span class="hljs-keyword">continue</span>
		}
		<span class="hljs-built_in">new</span> := old
		<span class="hljs-comment">// 不要尝试获取饥饿的互斥锁，新到达的 goroutine 必须排队</span>
		<span class="hljs-keyword">if</span> old&#x26;mutexStarving == <span class="hljs-number">0</span> {
			<span class="hljs-built_in">new</span> |= mutexLocked  <span class="hljs-comment">//非饥饿状态，加锁</span>
		}
		<span class="hljs-keyword">if</span> old&#x26;(mutexLocked|mutexStarving) != <span class="hljs-number">0</span> {   <span class="hljs-comment">//饥饿状态，或者锁被抢占，等待者 + 1</span>
			<span class="hljs-built_in">new</span> += <span class="hljs-number">1</span> &#x3C;&#x3C; mutexWaiterShift
		}
		<span class="hljs-comment">// 当前 goroutine 将互斥锁切换到饥饿模式。</span>
		<span class="hljs-keyword">if</span> starving &#x26;&#x26; old&#x26;mutexLocked != <span class="hljs-number">0</span> {
			<span class="hljs-built_in">new</span> |= mutexStarving
		}
		<span class="hljs-keyword">if</span> awoke {
			<span class="hljs-comment">//清除awoke标识</span>
			<span class="hljs-built_in">new</span> &#x26;^= mutexWoken
		}
		<span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&#x26;m.state, old, <span class="hljs-built_in">new</span>) {
			<span class="hljs-keyword">if</span> old&#x26;(mutexLocked|mutexStarving) == <span class="hljs-number">0</span> {
				<span class="hljs-keyword">break</span> <span class="hljs-comment">// 上锁成功</span>
			}
			<span class="hljs-comment">// 第一次等待，添加到信号量队列的队首</span>
			queueLifo := waitStartTime != <span class="hljs-number">0</span>
			<span class="hljs-keyword">if</span> waitStartTime == <span class="hljs-number">0</span> {
				waitStartTime = runtime_nanotime()
			}
			runtime_SemacquireMutex(&#x26;m.sema, queueLifo, <span class="hljs-number">1</span>)
            <span class="hljs-comment">//设置饥饿标记</span>
			starving = starving || runtime_nanotime()-waitStartTime > starvationThresholdNs
			old = m.state
			<span class="hljs-keyword">if</span> old&#x26;mutexStarving != <span class="hljs-number">0</span> {
				<span class="hljs-comment">//加锁并将waiter数量减1</span>
				delta := <span class="hljs-type">int32</span>(mutexLocked - <span class="hljs-number">1</span>&#x3C;&#x3C;mutexWaiterShift)
				<span class="hljs-keyword">if</span> !starving || old>>mutexWaiterShift == <span class="hljs-number">1</span> {
					<span class="hljs-comment">//非饥饿状态的goroutine,最后一个waiter已经不饥饿了，清除标记</span>
					delta -= mutexStarving
				}
				atomic.AddInt32(&#x26;m.state, delta)
				<span class="hljs-keyword">break</span>
			}
			awoke = <span class="hljs-literal">true</span>
			iter = <span class="hljs-number">0</span>
		} <span class="hljs-keyword">else</span> {
			old = m.state
		}
	}
}
<span class="copy-code-btn">复制代码</span></code></pre>
<p>代码结合注释也很难看懂，再结合流程图看一下。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/492caf4e05f04a609bc3f0b2ba6be10d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" alt="Mutex抢锁大致流程 (1).png" loading="lazy"></p>
<p>获取锁的goroutine很幸运的话，可以通过Fast path很快获取锁，我们来一步步分析一下lockSlow函数的实现。
首先定义了当前goroutine用到的一些变量信息，然后使用old保存当前锁的状态。</p>
<pre><code class="hljs language-go copyable" lang="go"><span class="hljs-keyword">var</span> waitStartTime <span class="hljs-type">int64</span>
	starving := <span class="hljs-literal">false</span>   <span class="hljs-comment">//标识当前goroutine是否饥饿模式</span>
	awoke := <span class="hljs-literal">false</span>  <span class="hljs-comment">//唤醒标记，初次进入for循环为false，之后以从sema优先队列中唤醒的身份进入for循环</span>
	iter := <span class="hljs-number">0</span>   <span class="hljs-comment">//自旋次数，用来判断是否可以继续自旋获取锁</span>
old := m.state  <span class="hljs-comment">//当前的锁状态        </span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>然后代码就进入到了for循环，<strong>lockSlow的实现效果是尽可能少的循环，但是一定使获取锁的goroutine得到锁</strong>。for循环中，当前抢锁的goroutine发现锁还没有被释放(正常模式下)，则调用runtime_canSpin自旋等待一会，期望锁能够被释放，这期间，程序还做了其他一些事情，比如通过设置Mutex的awoke状态，尽量使得Unlock程序不要再唤醒sema优先队列中的goroutine了，因为参与竞争锁的goroutine越多，得到锁的概率越小！</p>
<pre><code class="hljs language-scss copyable" lang="scss">	for {
		<span class="hljs-comment">//锁是非饥饿状态，并且未释放，尝试自旋</span>
		if old&#x26;(mutexLocked|mutexStarving) == mutexLocked &#x26;&#x26; <span class="hljs-built_in">runtime_canSpin</span>(iter) {
			<span class="hljs-comment">// 主动自旋的场景</span>
			<span class="hljs-comment">// 尝试设置 mutexWoken 标志以通知 Unlock 不唤醒其他阻塞的 goroutine</span>
			if !awoke &#x26;&#x26; old&#x26;mutexWoken == <span class="hljs-number">0</span> &#x26;&#x26; old>>mutexWaiterShift != <span class="hljs-number">0</span> &#x26;&#x26;
				atomic<span class="hljs-selector-class">.CompareAndSwapInt32</span>(&#x26;m.state, old, old|mutexWoken) {
				awoke = true
			}
			<span class="hljs-built_in">runtime_doSpin</span>()    <span class="hljs-comment">//自旋</span>
			iter++
			old = m<span class="hljs-selector-class">.state</span>
			continue
		}
<span class="copy-code-btn">复制代码</span></code></pre>
<p>自旋等待之后，获取锁的goroutine命运有两个：</p>
<ul>
<li>当前锁已经被释放了，那么它就可以参与竞争了</li>
<li>当前锁没有被释放，又或者它参与锁竞争失败了，那么它就要进入sema的优先队列了</li>
</ul>
<p>不过不管结果如何，它都要走下边的通用逻辑，就是给Mutex设置新状态。有下边几个步骤：</p>
<ul>
<li>判断锁的状态是否是正常模式，是的话就设置mutexLocked标志准备抢锁</li>
<li>如果锁的状态是没有被释放，或者是饥饿模式的话，当前goroutine一定要进sema优先队列了，这时候设置锁的等待者+1</li>
<li>如果锁已经被标记为饥饿模式了，并且原来锁并没有被释放，那么将锁给打上饥饿的标记。有的读者可能会问了，为什么只有锁没有被释放的时候才打上饥饿标记呢？这是因为Unlock方法是根据锁是否为饥饿模式来从sema优先队列中唤醒goroutine的，也就是<strong>锁为饥饿模式时，优先队列中必须还有等待的goroutine</strong>。</li>
<li>如果有awoke标记的话，将锁上的mutexWoken标记给擦除掉，因为不管当前goroutine最终进入sema优先队列还是获取到锁，新状态都应该清楚awoke标记。</li>
</ul>
<pre><code class="hljs language-go copyable" lang="go">                <span class="hljs-built_in">new</span> := old
		<span class="hljs-comment">// 不要尝试获取饥饿的互斥锁，新到达的 goroutine 必须排队</span>
		<span class="hljs-keyword">if</span> old&#x26;mutexStarving == <span class="hljs-number">0</span> {
			<span class="hljs-built_in">new</span> |= mutexLocked  <span class="hljs-comment">//非饥饿状态，加锁</span>
		}
		<span class="hljs-keyword">if</span> old&#x26;(mutexLocked|mutexStarving) != <span class="hljs-number">0</span> {   <span class="hljs-comment">//饥饿状态，或者锁被抢占，等待者 + 1</span>
			<span class="hljs-built_in">new</span> += <span class="hljs-number">1</span> &#x3C;&#x3C; mutexWaiterShift
		}
		<span class="hljs-comment">// 当前 goroutine 将互斥锁切换到饥饿模式。</span>
		<span class="hljs-keyword">if</span> starving &#x26;&#x26; old&#x26;mutexLocked != <span class="hljs-number">0</span> {
			<span class="hljs-built_in">new</span> |= mutexStarving
		}
		<span class="hljs-keyword">if</span> awoke {
			<span class="hljs-comment">//清除awoke标识</span>
			<span class="hljs-built_in">new</span> &#x26;^= mutexWoken
		}
<span class="copy-code-btn">复制代码</span></code></pre>
<p>设置状态的步骤走完了，接下来就是CAS了，有两个结局：CAS成功 or CAS失败。<strong>失败是成功之母，CAS失败记录当前锁的状态，再次走for循环就好了，注意这时候不用更新spin计数，因为抢锁失败并没有进入sema优先队列</strong>！当然CAS成功了也并不是万事大吉了，如果锁是在正常情况下被上锁成功的话，那么恭喜当前goroutine成功获取到了锁；否则是一定要进入sema优先队列的，但是具体是被插入到头部还是尾部，则要分情况而定，这时候waitStartTime就发挥作用了，根据它不仅能判断出来抢锁的goroutine是否是第一次要被插入sema优先队列，还能判断当前锁状态是否已经达到饥饿阈值了。</p>
<p>我们先来说goroutine是否是第一次要被插入sema优先队列的情况，是插入到尾部，这样只能等到下一轮调度唤醒了；如果当前goroutine不是第一次插入到sema优先队列，程序会将它插入到头部，这样下一个唤醒的依然是它，增加了它获取到锁的概率！</p>
<p>计算当前锁状态模式的代码是goroutine从sema优先队列中被唤醒之后，根据waitStartTime的记录和上边starving的标识，如果当前goroutine等待锁时间超过了1ms，那么当前goroutine就会将锁标记为饥饿(注意这个时候并没有给Mutex打上饥饿的标识，只是标记为饥饿，如果接下来当前goroutine仍然获取不到锁，那么接下来的循环中会做这个事情)。这个时候再次判断锁的状态，如果锁为饥饿模式，那么就直接把锁交给当前请求锁的goroutine就好了，否则当前被唤醒的goroutine只能进行新一轮抢锁了(重新设置自旋计数器)。</p>
<pre><code class="hljs language-ini copyable" lang="ini">if atomic.CompareAndSwapInt32(&#x26;m.state, old, new) {
			if old&#x26;(mutexLocked|mutexStarving) == 0 {
				break // 上锁成功
			}
			// 第一次等待，添加到信号量队列的队首
			queueLifo := waitStartTime != 0
			if <span class="hljs-attr">waitStartTime</span> == <span class="hljs-number">0</span> {
				<span class="hljs-attr">waitStartTime</span> = runtime_nanotime()
			}
			runtime_SemacquireMutex(&#x26;m.sema, queueLifo, 1)
            //设置饥饿标记
			<span class="hljs-attr">starving</span> = starving || runtime_nanotime()-waitStartTime > starvationThresholdNs
			<span class="hljs-attr">old</span> = m.state
			if old&#x26;mutexStarving != 0 {
				//加锁并将waiter数量减1
				delta := int32(mutexLocked - 1&#x3C;&#x3C;mutexWaiterShift)
				if !starving || old>><span class="hljs-attr">mutexWaiterShift</span> == <span class="hljs-number">1</span> {
					//非饥饿状态的goroutine,最后一个waiter已经不饥饿了，清除标记
					delta <span class="hljs-attr">-</span>= mutexStarving
				}
				atomic.AddInt32(&#x26;m.state, delta)
				break
			}
			<span class="hljs-attr">awoke</span> = <span class="hljs-literal">true</span>
			<span class="hljs-attr">iter</span> = <span class="hljs-number">0</span>
		} else {
			<span class="hljs-attr">old</span> = m.state
		}
<span class="copy-code-btn">复制代码</span></code></pre>
<p>以上就是终极版本Mutex的Lock函数实现，接下来回答几个常见问题：</p>
<ul>
<li>
<ol>
<li>如果Mutex已经被标记成为“饥饿模式”了，什么时候会变为“正常模式”呢？</li>
</ol>
</li>
</ul>
<p>拥有 Mutex 的 waiter 发现下面两种情况的其中之一，它就会把这个 Mutex 转换成正常模式；第一此 waiter 已经是队列中的最后一个 waiter 了(通过代码<code>!starving || old>>mutexWaiterShift == 1</code>判断)，没有其它的等待锁的 goroutine 了；第二是此 waiter 的等待时间小于 1 毫秒(通过代码<code>starving = starving || runtime_nanotime()-waitStartTime > starvationThresholdNs</code>判断)。</p>
<ul>
<li>
<ol start="2">
<li>为什么要有饥饿模式？</li>
</ol>
</li>
</ul>
<p>饥饿模式是对公平性和性能的一种平衡，它避免了某些 goroutine 长时间的等待锁。在饥饿模式下，优先对待的是那些一直在等待的 waiter。正常模式拥有更好的性能，因为即使有等待抢锁的 waiter，goroutine 也可以连续多次获取到锁。</p>
<ul>
<li>
<ol start="3">
<li>饥饿模式下Mutex是如何工作的?</li>
</ol>
</li>
</ul>
<p>饥饿模式下，会直接把锁交给队列第一个 goroutine。这块再代码中有体现。</p>
<p>本节内容建议读着多读几遍，最好是从文章开始顺着历史发展的脉络思考，如果还有什么问题，可以在留言区和我一块交流。</p>
<p>我们再接着看Unlock方法。</p>
<h3 data-id="heading-11">4.3 Sync.Mutex 终极版本的Unlock函数实现</h3>
<p>相对于Lock函数，Unlock函数的代码逻辑比较好理解，我们先看一下流程图：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e556320ebcdf45ecb1d240f10ff341a2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" alt="Mutex释放锁大致流程.png" loading="lazy"></p>
<p>代码如下：</p>
<pre><code class="hljs language-go copyable" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> Unlock() {
	<span class="hljs-comment">// Fast path: 将锁标记去掉</span>
	<span class="hljs-built_in">new</span> := atomic.AddInt32(&#x26;m.state, -mutexLocked)
	<span class="hljs-keyword">if</span> <span class="hljs-built_in">new</span> != <span class="hljs-number">0</span> {   <span class="hljs-comment">//还需要做其他的事</span>
		m.unlockSlow(<span class="hljs-built_in">new</span>)
	}
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> unlockSlow(<span class="hljs-built_in">new</span> <span class="hljs-type">int32</span>) {
    <span class="hljs-comment">//无锁的mutex释放锁会panic</span>
	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">new</span>+mutexLocked)&#x26;mutexLocked == <span class="hljs-number">0</span> {
		throw(<span class="hljs-string">"sync: unlock of unlocked mutex"</span>)
	}
	<span class="hljs-keyword">if</span> <span class="hljs-built_in">new</span>&#x26;mutexStarving == <span class="hljs-number">0</span> {
		old := <span class="hljs-built_in">new</span>
		<span class="hljs-keyword">for</span> {
			<span class="hljs-comment">//锁上没有goroutine等待或者有被唤醒的goroutine改变了锁的状态，直接return即可</span>
			<span class="hljs-keyword">if</span> old>>mutexWaiterShift == <span class="hljs-number">0</span> || old&#x26;(mutexLocked|mutexWoken|mutexStarving) != <span class="hljs-number">0</span> {
				<span class="hljs-keyword">return</span>
			}
			<span class="hljs-comment">// 减少等待者并设置Mutex唤醒标记，CAS释放锁</span>
			<span class="hljs-built_in">new</span> = (old - <span class="hljs-number">1</span>&#x3C;&#x3C;mutexWaiterShift) | mutexWoken
			<span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&#x26;m.state, old, <span class="hljs-built_in">new</span>) {
				runtime_Semrelease(&#x26;m.sema, <span class="hljs-literal">false</span>, <span class="hljs-number">1</span>)   <span class="hljs-comment">//锁在正常模式下从sema优先队列尾部唤醒新的goroutine</span>
				<span class="hljs-keyword">return</span>
			}
			old = m.state
		}
	} <span class="hljs-keyword">else</span> {
		<span class="hljs-comment">//饥饿模式下，从优先队列的头部唤醒等待的goroutine，Lock方法会直接将锁给它</span>
		runtime_Semrelease(&#x26;m.sema, <span class="hljs-literal">true</span>, <span class="hljs-number">1</span>)
	}
}
<span class="copy-code-btn">复制代码</span></code></pre>
<p>先将锁标记去掉，但是state其他字段并不为0的话，还需要做一些额外的工作，这就是<code>unlockSlow</code>的代码逻辑，如果是饥饿模式的话，从优先队列的头部唤醒一个goroutine，分析Lock代码的时候我们知道，饥饿模式下会将锁直接给这个唤醒的goroutine; 正常模式下进入for循环，如果锁的的其他状态已经被改变的情况下，unlockSlow什么也不需要做，return即可，否则将锁等待者数量-1，并设置唤醒标识，CAS操作成功之后，从sema优先队列尾部唤醒一个goroutine参与到抢锁工作中。</p>
<p>以上就是Sync.Mutex终极版本的全部实现了。下边我们再来看一下Sync.Mutex使用中都有哪些坑。</p>
<h2 data-id="heading-12">5. Sync.Mutex使用时常见的坑</h2>
<p>关于Mutex的使用，一不小心就会产生死锁或者panic，使用不得当会有很大的性能开销，接下来我们结合上边的源码分析一下。</p>
<ul>
<li>Mutex对goroutine无状态性</li>
</ul>
<p>看过源代码，我们不难看出不同的goroutine操作Mutex这一个全局变量是没有状态记录的，这样会出现两种情况：1.一个goroutine可以释放掉另一个goroutine的锁；2.goroutine一旦重入设置两次Lock，就会死锁；建议使用Mutex时，Lock/Unlock要成对出现，最好是封装到一个函数中，使用defer是一个好的方案。也可以对Mutex的无状态性做一个封装，例如实现锁的重入，添加一些锁的检测机制等等。</p>
<ul>
<li>Mutex 千万不能被复制</li>
</ul>
<p>这里所说的千万不能被复制并不是Go语言在语法上做了限制，而是在使用过程中，为了避免不必要的麻烦，不要拷贝Mutex，从源码分析我们看到，Mutex可以被千千万万个goroutine使用，拷贝Mutex时，只是拷贝的一个临时状态而已。复制之后，一个新 Mutex 可能莫名处于持有锁、唤醒或者饥饿状态，甚至等阻塞等待数量远远大于0。而原锁 Unlock 的时候，却不会影响复制锁。</p>
<p>关于锁复制后产生的严重后果，推荐阅读：<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FOYGVR0d-fq1hgOvrdsUnYA" target="_blank" title="https://mp.weixin.qq.com/s/OYGVR0d-fq1hgOvrdsUnYA" ref="nofollow noopener noreferrer">当 Go struct 遇上 Mutex</a></p>
<ul>
<li>产生强烈的锁竞争时怎么办</li>
</ul>
<p>当线上QPS很高时，如果使用了Mutex，可能会发现大量的goroutine阻塞在Mutex的Lock函数上，这个时候就要想办法优化程序，首先应该尽量少使用Mutex，如果非要使用，可以采用分片管理数据的方式，Mutex保护的程序逻辑不应该过于复杂，因为大量goroutine阻塞在Mutex的Lock函数上会产生饥饿，饥饿带来的问题是性能更差，不能更快的恢复到正常模式将是一场灾难。</p>
<p>关于锁竞争的优化，推荐阅读：<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FtcsSgCRj-tBDD7qyq53IAw" target="_blank" title="https://mp.weixin.qq.com/s/tcsSgCRj-tBDD7qyq53IAw" ref="nofollow noopener noreferrer">一次错误使用 go-cache 导致出现的线上问题</a></p>
<h2 data-id="heading-13">6. 小结</h2>
<p>DDD设计中有关战略模型的分析指出，每一个复杂系统都有一个演进的过程，我们不要期望一次就将它做的很好。我觉得这个观点应用在Go语言的Sync.Mutex设计上非常恰当，“罗马不是一天建成的”，我们不得不佩服Sync.Mutex开发者的匠心精神，一次次打磨，精益求精的实现了现在的Sync.Mutex，虽然它可能还不够完美，还能够继续雕琢，但是这个发现问题并解决问题的思路和精神，是我们应该学习的。本文还分析了很多关于Sync.Mutex实现的基础知识：原子性、信号量、CAS；还指出了使用Mutex时应该注意的问题，希望感兴趣的读者在留言区继续和我交流！</p>
<p><strong>Reference:</strong></p>
<ul>
<li>
<p>Mutex 源码分析:
<a href="https://link.juejin.cn?target=https%3A%2F%2Fcolobu.com%2F2018%2F12%2F18%2Fdive-into-sync-mutex%2F" target="_blank" title="https://colobu.com/2018/12/18/dive-into-sync-mutex/" ref="nofollow noopener noreferrer">colobu.com/2018/12/18/…</a></p>
</li>
<li>
<p>原子操作是如何实现的
<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fluohaha%2FMyBlog%2Fissues%2F3" target="_blank" title="https://github.com/luohaha/MyBlog/issues/3" ref="nofollow noopener noreferrer">github.com/luohaha/MyB…</a></p>
</li>
<li>
<p>百度百科：信号量
<a href="https://link.juejin.cn?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%25E4%25BF%25A1%25E5%258F%25B7%25E9%2587%258F%2F9807501" target="_blank" title="https://baike.baidu.com/item/%E4%BF%A1%E5%8F%B7%E9%87%8F/9807501" ref="nofollow noopener noreferrer">baike.baidu.com/item/%E4%BF…</a></p>
</li>
<li>
<p>一文彻底搞懂CAS实现原理
<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F94762520" target="_blank" title="https://zhuanlan.zhihu.com/p/94762520" ref="nofollow noopener noreferrer">zhuanlan.zhihu.com/p/94762520</a></p>
</li>
<li>
<p>Go sync.Mutex 深入不浅出
<a href="https://juejin.cn/post/6984980411008958471/#heading-10" target="_blank" title="https://juejin.cn/post/6984980411008958471/#heading-10">juejin.cn/post/698498…</a></p>
</li>
<li>
<p>一次错误使用 go-cache 导致出现的线上问题
<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FtcsSgCRj-tBDD7qyq53IAw" target="_blank" title="https://mp.weixin.qq.com/s/tcsSgCRj-tBDD7qyq53IAw" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/tcsSgCRj-…</a></p>
</li>
<li>
<p>当 Go struct 遇上 Mutex
<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FOYGVR0d-fq1hgOvrdsUnYA" target="_blank" title="https://mp.weixin.qq.com/s/OYGVR0d-fq1hgOvrdsUnYA" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/OYGVR0d-f…</a></p>
</li>
</ul></body></html></div></div></article> <!----> <div class="article-end" data-v-1e8be6f4 data-v-8e24b4d2><div class="tag-list-box" data-v-1e8be6f4 data-v-8e24b4d2><div class="tag-list" data-v-1e8be6f4 data-v-8e24b4d2><div class="tag-list-title" data-v-1e8be6f4 data-v-8e24b4d2>分类：</div> <a href="/backend" target="_blank" rel="" class="item category-item" data-v-8e24b4d2><span class="tag-title" data-v-8e24b4d2>后端</span></a></div> <div class="tag-list" data-v-1e8be6f4 data-v-8e24b4d2><div class="tag-list-title" data-v-1e8be6f4 data-v-8e24b4d2>标签：</div> <div class="tag-list-container" data-v-1e8be6f4 data-v-8e24b4d2><a href="/tag/Go" target="_blank" rel="" class="item tag-item" data-v-8e24b4d2><span class="tag-title" data-v-8e24b4d2>Go</span></a><a href="/tag/%E6%BA%90%E7%A0%81" target="_blank" rel="" class="item tag-item" data-v-8e24b4d2><span class="tag-title" data-v-8e24b4d2>源码</span></a></div></div> <!----></div> <!----> <div class="extension-banner" data-v-fea06212 data-v-8e24b4d2><span class="banner-icon" data-v-fea06212></span> <div class="banner-wrapper" data-v-fea06212><a class="banner-title" data-v-fea06212>
      安装掘金浏览器插件
    </a> <div class="banner-content" data-v-fea06212>多内容聚合浏览、多引擎快捷搜索、多工具便捷提效、多模式随心畅享，你想要的，这里都有！</div></div> <a class="banner-action" data-v-fea06212>前往安装</a></div></div> <!----> <!----><!----><!----><!----><!----></div> <!----> <!----> <div st:block="sidebar" class="sidebar" data-v-cceb3a2e data-v-8e24b4d2><div class="sidebar-block author-block pure" data-v-71f2d09e data-v-8e1847b4 data-v-cceb3a2e><a href="/user/2101921964623992" target="_blank" rel="" class="user-item item" data-v-8e1847b4><img loading="eager" src="https://p3-passport.byteimg.com/img/user-avatar/ce5ce2f18b2ab595a782ac86c8883f9b~100x100.image" alt="" class="lazy avatar avatar" data-v-55b483d2 data-v-0b45085c data-v-8e1847b4> <div class="info-box" data-v-8e1847b4><span to="[object Object]" blank="true" class="username" data-v-2b2ca9ee data-v-8e1847b4><span class="name" style="max-width:128px;" data-v-2b2ca9ee>
    烟花易冷DarkPrince
  </span> <span blank="true" class="rank" data-v-19095f0c data-v-2b2ca9ee><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8AQMAAAAAMksxAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAA5JREFUKM9jGAWjAAcAAAIcAAE27nY6AAAAAElFTkSuQmCC" alt="创作等级LV.4" title="创作等级LV.4" class="lazy" style="aspect-ratio:NaN;" data-v-55b483d2 data-v-19095f0c></span> <!----> <!----> </span> <div title="后端开发工程师 @ 百度" class="position" data-v-8e1847b4>
        后端开发工程师 @ 百度
      </div></div></a> <div class="operate-btn" data-v-71f2d09e data-v-8e1847b4><button st:name="followBtn" class="ui-btn follow-btn primary large default attention" data-v-2afc21b6 data-v-8e1847b4><!----> 
    关注
  </button> <a href="/notification/im?participantId=2101921964623992" class="im-button im-btn" data-v-11443840 data-v-8e1847b4><!----> <div data-v-11443840>私信</div></a></div> <div class="cut-off" data-v-71f2d09e data-v-8e1847b4></div>  <div class="stat-item item" data-v-71f2d09e data-v-8e1847b4><svg xmlns="http://www.w3.org/2000/svg" width="25" height="26" viewBox="0 0 25 26" class="zan" data-v-71f2d09e data-v-8e1847b4><g fill="none" fill-rule="evenodd" transform="translate(0 .57)" data-v-71f2d09e data-v-8e1847b4><ellipse cx="12.5" cy="12.57" fill="#E1EFFF" rx="12.5" ry="12.57" data-v-71f2d09e data-v-8e1847b4></ellipse><path fill="#7BB9FF" d="M8.596 11.238V19H7.033C6.463 19 6 18.465 6 17.807v-5.282c0-.685.483-1.287 1.033-1.287h1.563zm4.275-4.156A1.284 1.284 0 0 1 14.156 6c.885.016 1.412.722 1.595 1.07.334.638.343 1.687.114 2.361-.207.61-.687 1.412-.687 1.412h3.596c.38 0 .733.178.969.488.239.317.318.728.21 1.102l-1.628 5.645a1.245 1.245 0 0 1-1.192.922h-7.068v-7.889c1.624-.336 2.623-2.866 2.806-4.029z" data-v-71f2d09e data-v-8e1847b4></path></g></svg> <span class="content" data-v-71f2d09e data-v-8e1847b4>
      获得点赞
      <span class="count" style="display:none;" data-v-71f2d09e data-v-8e1847b4>
         482
      </span></span></div> <div class="stat-item item" data-v-71f2d09e data-v-8e1847b4><svg width="25" height="25" viewBox="0 0 25 25" class="icon stat-view-icon" data-v-71f2d09e data-v-8e1847b4><g fill="none" fill-rule="evenodd" data-v-71f2d09e data-v-8e1847b4><circle cx="12.5" cy="12.5" r="12.5" fill="#E1EFFF" data-v-71f2d09e data-v-8e1847b4></circle><path fill="#7BB9FF" d="M4 12.5S6.917 7 12.75 7s8.75 5.5 8.75 5.5-2.917 5.5-8.75 5.5S4 12.5 4 12.5zm8.75 2.292c1.208 0 2.188-1.026 2.188-2.292 0-1.266-.98-2.292-2.188-2.292-1.208 0-2.188 1.026-2.188 2.292 0 1.266.98 2.292 2.188 2.292z" data-v-71f2d09e data-v-8e1847b4></path></g></svg> <span class="content" data-v-71f2d09e data-v-8e1847b4>
      文章被阅读
      <span class="count" style="display:none;" data-v-71f2d09e data-v-8e1847b4>
         106,773
      </span></span></div> <!----></div> <!----> <!----> <!----> <!----> <div class="sticky-block-box" style="display:none;" data-v-cceb3a2e><div class="sidebar-block catalog-block pure" style="display:none;" data-v-71f2d09e data-v-79f817f2 data-v-cceb3a2e><nav class="article-catalog" style="display:none;" data-v-6c50ea67 data-v-79f817f2><div class="catalog-title" data-v-6c50ea67>目录</div> <div class="catalog-body" data-v-6c50ea67><ul class="catalog-list" style="margin-top:0px;" data-v-6c50ea67></ul></div></nav></div> <!----></div></div> <!----></div> <!----></main> <!----></div> <!----> <div class="global-component-box"><!----> <!----> <!----> <!----> <!----> <!----></div> <!----><!----><!----><!----><!----><!----><!----> <!----> <!----> <div data-transfer="true" align-center="" class="risk-modal byte-modal"><div class="byte-modal__mask" style="z-index:2957;display:none;"></div><div class="byte-modal__wrapper" style="z-index:2957;display:none;"><div class="byte-modal__content" style="width:350px;"><!----><div class="byte-modal__body"><div class="risk-modal-inner"><div class="risk-modal-title">温馨提示</div> <div>当前操作失败，如有疑问，可点击申诉</div> <div class="risk-modal-footer"><button type="button" class="cancel-button risk-button byte-btn byte-btn--default byte-btn--large"><!----><!----><span><span>前往申诉</span></span></button> <button type="button" class="risk-button byte-btn byte-btn--primary byte-btn--large"><!----><!----><span><span>我知道了</span></span></button></div></div></div><!----></div></div></div> <!----><!----><!----><!----><!----></div></div></div><script>window.__NUXT__=(function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U){v.loading=a;v.skeleton=d;v.cursor=f;v.data=[];v.total=b;v.hasMore=d;L.id=A;L.self_description=t;L.followed=a;L.viewerIsFollowing=t;L.community=t;L.subscribedTagCount=b;L.wroteBookCount=b;L.boughtBookCount=b;L.isBindedPhone=a;L.level=J;L.user_id=A;L.user_name=I;L.company="百度";L.job_title="后端开发工程师";L.avatar_large="https:\u002F\u002Fp3-passport.byteacctimg.com\u002Fimg\u002Fuser-avatar\u002Fce5ce2f18b2ab595a782ac86c8883f9b~300x300.image";L.description="我愿化身石桥，忍受五百年风吹、雨打、日晒，等你走过......";L.followee_count=38;L.follower_count=401;L.post_article_count=21;L.digg_article_count=14;L.got_digg_count=482;L.got_view_count=106773;L.post_shortmsg_count=b;L.digg_shortmsg_count=b;L.isfollowed=a;L.favorable_author=b;L.power=K;L.study_point=b;L.university={university_id:f,name:e,logo:e};L.major={major_id:f,parent_id:f,name:e};L.student_status=b;L.select_event_count=b;L.select_online_course_count=b;L.identity=b;L.is_select_annual=a;L.select_annual_rank=b;L.annual_list_type=b;L.extraMap={};L.is_logout=b;L.annual_info=[];L.account_amount=b;L.user_growth_info={user_id:2101921964623992,jpower:K,jscore:131,jpower_level:J,jscore_level:z,jscore_title:"新星掘友",author_achievement_list:[],vip_level:g,vip_title:"初学乍练",jscore_next_level_score:150,jscore_this_level_mini_score:30};L.is_vip=a;L.become_author_days=b;L.collection_set_article_count=b;L.recommend_article_count_daily=b;L.article_collect_count_daily=b;L.juejinPower=K;L.jobTitle="后端开发工程师";L.roles={isBookAuthor:a,isFavorableAuthor:a,isCobuilder:a,isAdmin:a};L.username=I;L.blogAddress=t;L.selfDescription="我愿化身石桥，忍受五百年风吹、雨打、日晒，等你走过......";L.beLikedCount=482;L.beReadCount=106773;L.followerCount=401;L.followingCount=38;L.collectionCount=b;L.createdCollectionCount=b;L.followingCollectionCount=b;L.postedPostsCount=21;L.pinCount=b;L.likedArticleCount=14;L.likedPinCount=b;L.avatar="https:\u002F\u002Fp3-passport.byteacctimg.com\u002Fimg\u002Fuser-avatar\u002Fce5ce2f18b2ab595a782ac86c8883f9b~300x300.image";L.latestLoginedInAt=c;L.createdAt=c;L.updatedAt=c;L.phoneNumber=e;L.titleDescription=e;L.followeesCount=38;L.applyEventCount=b;L.need_lead=b;L.followTopicCnt=b;return {layout:"default",data:[{renderPost:d,additionalDataUseCSR:d}],fetch:[{bdPageUrlForNav:"https:\u002F\u002Fbd.juejin.cn?utm_campaign=bd&utm_source=web&utm_medium=nav",queryString:e,isShowUserDropdownList:a,isShowAddMoreList:a,isFocus:a,isPhoneMenuShow:a,visibleBadge:a,placeholder:e,hiddenProperty:"hidden",searchHistoryVisible:a,searchHistoryItems:[],tabBadge:c,isChangePlaceholder:d,showMallBridge:a,removeSearchInputKeyupListener:c}],error:c,state:{view:{activityIndex:{activityList:[],pageInfo:{hasNextPage:a,endCursor:e},afterPosition:e,activityListIsLoading:d,activityListIsError:a,userActivityList:[],placeholder:e,actionType:{FETCH:"@\u002Fview\u002Factivity-index\u002FFETCH",FETCH_RECOMMEND_LIST:"@\u002Fview\u002Factivity-index\u002FFETCH_RECOMMEND_LIST",RESET_ACTIVITY_LIST:"@\u002Fview\u002Factivity-index\u002FRESET_ACTIVITY_LIST",FETCH_USER_ACTIVITY_LIST:"@\u002Fview\u002Factivity-index\u002FFETCH_USER_ACTIVITY_LIST",FETCH_NEW_COUNT:"@\u002Fview\u002Factivity-index\u002FFETCH_NEW_COUNT",DELETE_ACTIVITY:"@\u002Fview\u002Factivity-index\u002FDELETE_ACTIVITY",TOGGLE_FOLLOW_USER:"@\u002Fview\u002Factivity-index\u002FTOGGLE_FOLLOW_USER",FETCH_ENTRY_COMMENT_LIST:"@\u002Fview\u002Factivity-index\u002FFETCH_ENTRY_COMMENT_LIST",UPDATE_LIST_LOADING:"@\u002Fview\u002Factivity-index\u002FUPDATE_LIST_LOADING",RESET:"@\u002Fview\u002Factivity-index\u002FRESET"},hotList:{list:[],after:e,loading:a,hasNextPage:a,actionType:{UPDATE_STATE:"@\u002Fview\u002Factivity-index\u002Fhot-list\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Factivity-index\u002Fhot-list\u002FFETCH_MORE",FETCH:"@\u002Fview\u002Factivity-index\u002Fhot-list\u002FFETCH",RESET:"@\u002Fview\u002Factivity-index\u002Fhot-list\u002FRESET"}},sidebar:{bannerList:[],actionType:{RESET:"@\u002Fview\u002Factivity-index\u002Fsidebar\u002FRESET",UPDATE_STATE:"@\u002Fview\u002Factivity-index\u002Fsidebar\u002FUPDATE_STATE",FETCH_BANNER:"@\u002Fview\u002Factivity-index\u002Fsidebar\u002FFETCH_BANNER"},recommend:{pageSize:h,page:b,total:b,pointer:c,lastPointer:c,list:[],loading:a,error:c,canPrev:d,canNext:d,linkList:[],lastFetchOnServer:a,actionType:{UPDATE:"@\u002Fview\u002Factivity-index\u002Fsidebar\u002Frecommend-topic-list\u002FUPDATE",FETCH:"@\u002Fview\u002Factivity-index\u002Fsidebar\u002Frecommend-topic-list\u002FFETCH",FORCE_FETCH:"@\u002Fview\u002Factivity-index\u002Fsidebar\u002Frecommend-topic-list\u002FFORCE_FETCH",FETCH_MORE:"@\u002Fview\u002Factivity-index\u002Fsidebar\u002Frecommend-topic-list\u002FFETCH_MORE",RESET:"@\u002Fview\u002Factivity-index\u002Fsidebar\u002Frecommend-topic-list\u002FRESET"},after:b},followed:{pageSize:h,page:b,total:b,pointer:c,lastPointer:c,list:[],loading:a,error:c,canPrev:d,canNext:d,linkList:[],lastFetchOnServer:a,actionType:{UPDATE:"@\u002Fview\u002Factivity-index\u002Fsidebar\u002Ffollowed-topic-list\u002FUPDATE",FETCH:"@\u002Fview\u002Factivity-index\u002Fsidebar\u002Ffollowed-topic-list\u002FFETCH",FORCE_FETCH:"@\u002Fview\u002Factivity-index\u002Fsidebar\u002Ffollowed-topic-list\u002FFORCE_FETCH",FETCH_MORE:"@\u002Fview\u002Factivity-index\u002Fsidebar\u002Ffollowed-topic-list\u002FFETCH_MORE",RESET:"@\u002Fview\u002Factivity-index\u002Fsidebar\u002Ffollowed-topic-list\u002FRESET"},after:b},recommendPin:{list:[],after:e,loading:a,hasNextPage:d,actionType:{UPDATE_STATE:"@\u002Fview\u002Factivity-index\u002Fsidebar\u002Frecommend-pin-list\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Factivity-index\u002Fsidebar\u002Frecommend-pin-list\u002FFETCH_MORE",FETCH:"@\u002Fview\u002Factivity-index\u002Fsidebar\u002Frecommend-pin-list\u002FFETCH",RESET:"@\u002Fview\u002Factivity-index\u002Fsidebar\u002Frecommend-pin-list\u002FRESET"}}},topicPinList:{pageSize:h,page:g,total:b,pointer:c,lastPointer:c,list:[],loading:a,error:c,canPrev:d,canNext:d,linkList:[],lastFetchOnServer:a,actionType:{UPDATE:"@\u002Fview\u002Factivity-index\u002Ftopic-pin-list\u002FUPDATE",FETCH:"@\u002Fview\u002Factivity-index\u002Ftopic-pin-list\u002FFETCH",FORCE_FETCH:"@\u002Fview\u002Factivity-index\u002Ftopic-pin-list\u002FFORCE_FETCH",FETCH_MORE:"@\u002Fview\u002Factivity-index\u002Ftopic-pin-list\u002FFETCH_MORE",RESET:"@\u002Fview\u002Factivity-index\u002Ftopic-pin-list\u002FRESET"},topicId:e,navList:[{type:l,name:l,title:"推荐 ",id:l},{type:n,name:n,title:"热门 ",id:n},{type:r,name:r,title:"关注 ",id:r},{type:i,name:"opensource",title:"开源推荐 ",id:"5c09ea2b092dcb42c740fe73"},{type:i,name:"recruitment",title:"内推招聘",id:"5abb61e1092dcb4620ca3322"},{type:i,name:"dating",title:"掘金相亲",id:"5abcaa67092dcb4620ca335c"},{type:i,name:"slacking",title:"上班摸鱼",id:"5c106be9092dcb2cc5de7257"},{type:i,name:"app",title:"应用安利",id:"5b514af1092dcb61bd72800d"},{type:i,name:"tool",title:"开发工具",id:"5abb67d2092dcb4620ca3324"},{type:i,name:"news",title:"New资讯",id:"5c46a17f092dcb4737217152"}],sortType:s}},search:{search_result_from:b,query:e,list:[],linkList:[],loading:a,skeleton:d,actionType:{FETCH:"@\u002Fview\u002Fsearch\u002FFETCH",FETCH_MORE:"@\u002Fview\u002Fsearch\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fsearch\u002FRESET"}},columnIndex:{list:{pageSize:h,page:g,total:b,pointer:c,lastPointer:c,list:[],loading:a,error:c,canPrev:d,canNext:d,linkList:[],lastFetchOnServer:a,actionType:{UPDATE:"@\u002Fview\u002FcolumnIndex\u002Flist\u002FUPDATE",FETCH:"@\u002Fview\u002FcolumnIndex\u002Flist\u002FFETCH",FORCE_FETCH:"@\u002Fview\u002FcolumnIndex\u002Flist\u002FFORCE_FETCH",FETCH_MORE:"@\u002Fview\u002FcolumnIndex\u002Flist\u002FFETCH_MORE",RESET:"@\u002Fview\u002FcolumnIndex\u002Flist\u002FRESET"},sort:o,category:"all"},hotList:{pageSize:h,page:g,total:b,pointer:c,lastPointer:c,list:[],loading:a,error:c,canPrev:d,canNext:d,linkList:[],lastFetchOnServer:a,actionType:{UPDATE:"@\u002Fview\u002FcolumnIndex\u002FhotList\u002FUPDATE",FETCH:"@\u002Fview\u002FcolumnIndex\u002FhotList\u002FFETCH",FORCE_FETCH:"@\u002Fview\u002FcolumnIndex\u002FhotList\u002FFORCE_FETCH",FETCH_MORE:"@\u002Fview\u002FcolumnIndex\u002FhotList\u002FFETCH_MORE",RESET:"@\u002Fview\u002FcolumnIndex\u002FhotList\u002FRESET"}}},timelineIndex:{tdkTemplates:[],categoryNavList:[],tagNavList:[],splitTagList:[],timelineAdList:[],list:[],sort:s,category:l,categoryId:e,tagId:e,tag:"全部",actionType:{FETCH_TIMELINE_LIST:"@\u002Fview\u002FtimelineIndex\u002FFETCH_TIMELINE_LIST",FETCH_CATEGORY_LIST:"@\u002Fview\u002FtimelineIndex\u002FFETCH_CATEGORY_LIST",FETCH_TAG_LIST:"@\u002Fview\u002FtimelineIndex\u002FFETCH_TAG_LIST",DELETE_ENTRY:"@\u002Fview\u002FtimelineIndex\u002FDELETE_ENTRY",DELETE_USER_ENTRIES:"@\u002Fview\u002FtimelineIndex\u002FDELETE_USER_ENTRIES",DELETE_TAG_ENTRIES:"@\u002Fview\u002FtimelineIndex\u002FDELETE_TAG_ENTRIES",FETCH_MORE:"@\u002Fview\u002FtimelineIndex\u002FFETCH_MORE",FETCH:"@\u002Fview\u002FtimelineIndex\u002FFETCH",RESET:"@\u002Fview\u002FtimelineIndex\u002FRESET"},serverRenderTimelineList:a,timelineList:{list:[],cursor:f,skeleton:d,loading:a,hasMore:d,categoryId:e,tagId:e,sort:e,actionType:{UPDATE_STATE:"timeline-list\u002FUPDATE_STATE",FETCH_MORE:"timeline-list\u002FFETCH_MORE",FETCH:"timeline-list\u002FFETCH",RESET:"timeline-list\u002FRESET"}},recommendList:{list:[],cursor:f,loading:a,skeleton:d,hasMore:d,actionType:{UPDATE_STATE:"recommend-list\u002FUPDATE_STATE",FETCH_MORE:"recommend-list\u002FFETCH_MORE",FETCH:"recommend-list\u002FFETCH",RESET:"recommend-list\u002FRESET"}},followingList:{list:[],cursor:f,skeleton:d,loading:a,hasMore:d,actionType:{UPDATE_STATE:"following-list\u002FUPDATE_STATE",FETCH_MORE:"following-list\u002FFETCH_MORE",FETCH:"following-list\u002FFETCH",RESET:"following-list\u002FRESET"}}},subscribe:{subscribed:{list:[],cursor:f,skeleton:d,loading:a,hasMore:a,actionType:{UPDATE_STATE:"view\u002Fsubscribe\u002Fsubscribed\u002Flist\u002FUPDATE_STATE",FETCH_MORE:"view\u002Fsubscribe\u002Fsubscribed\u002Flist\u002FFETCH_MORE",FETCH:"view\u002Fsubscribe\u002Fsubscribed\u002Flist\u002FFETCH",RESET:"view\u002Fsubscribe\u002Fsubscribed\u002Flist\u002FRESET"}},all:{list:[],cursor:f,loading:a,skeleton:d,hasMore:a,linkList:e,actionType:{UPDATE_STATE:"view\u002Fsubscribe\u002Fall\u002Flist\u002FUPDATE_STATE",FETCH_MORE:"view\u002Fsubscribe\u002Fall\u002Flist\u002FFETCH_MORE",FETCH:"view\u002Fsubscribe\u002Fall\u002Flist\u002FFETCH",RESET:"view\u002Fsubscribe\u002Fall\u002Flist\u002FRESET"}}},entryPublic:{entry:{user:{}},relatedEntryList:[],relatedCollectionList:[],actionType:{FETCH:"@\u002Fview\u002FentryPublic\u002FFETCH",RESET:"@\u002Fview\u002FentryPublic\u002FRESET"}},user:{user:{},serverRendered:a,userAnnuals:[],actionType:{FETCH:"@\u002Fview\u002Fuser\u002FFETCH",RESET:"@\u002Fview\u002Fuser\u002FRESET",UPDATE:"@\u002Fview\u002Fuser\u002FUPDATE",FETCH_ANNUALS:"@\u002Fview\u002Fuser\u002FFETCH_ANNUALS"},detailList:{actionType:{RESET:"@\u002Fview\u002Fuser\u002FdetailList\u002FRESET"},likeList:{list:[],cursor:f,hasMore:a,loading:a,skeleton:d,actionType:{FETCH:"@\u002Fview\u002Fuser\u002FdetailList\u002FlikePostList\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fuser\u002FdetailList\u002FlikePostList\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fuser\u002FdetailList\u002FlikePostList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fuser\u002FdetailList\u002FlikePostList\u002FRESET"}},postList:{list:[],hasMore:a,skeleton:a,loading:a,sort:o,actionType:{FETCH:"@\u002Fview\u002Fuser\u002FdetailList\u002FpostList\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fuser\u002FdetailList\u002FpostList\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fuser\u002FdetailList\u002FpostList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fuser\u002FdetailList\u002FpostList\u002FRESET"}},searchList:{list:[],hasMore:a,skeleton:a,loading:a,key_word:e,search_type:b,cursor:f,isPostSearch:a,actionType:{FETCH:"@\u002Fview\u002Fuser\u002FdetailList\u002FsearchList\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fuser\u002FdetailList\u002FsearchList\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fuser\u002FdetailList\u002FsearchList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fuser\u002FdetailList\u002FsearchList\u002FRESET"}},tagList:{list:[],loading:a,skeleton:d,hasMore:a,cursor:f,actionType:{FETCH:"@\u002Fview\u002Fuser\u002FdetailList\u002FtagList\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fuser\u002FdetailList\u002FtagList\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fuser\u002FdetailList\u002FtagList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fuser\u002FdetailList\u002FtagList\u002FRESET"}},collectionList:{list:[],userId:e,skeleton:d,hasMore:a,cursor:f,type:"created",loading:a,actionType:{FETCH:"@\u002Fview\u002Fuser\u002FdetailList\u002FcollectionList\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fuser\u002FdetailList\u002FcollectionList\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fuser\u002FdetailList\u002FcollectionList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fuser\u002FdetailList\u002FcollectionList\u002FRESET",TOGGLE_FOLLOW_COLLECTION:"@\u002Fview\u002Fuser\u002FdetailList\u002FcollectionList\u002FTOGGLE_FOLLOW_COLLECTION",FOLLOW_COLLECTION:"@\u002Fview\u002Fuser\u002FdetailList\u002FcollectionList\u002FFOLLOW_COLLECTION",UNFOLLOW_COLLECTION:"@\u002Fview\u002Fuser\u002FdetailList\u002FcollectionList\u002FUNFOLLOW_COLLECTION",DELELTE_COLLECTION:"@\u002Fview\u002Fuser\u002FdetailList\u002FcollectionList\u002FDELELTE_COLLECTION",ADD_COLLECTION:"@\u002Fview\u002Fuser\u002FdetailList\u002FcollectionList\u002FADD_COLLECTION",EDIT_COLLECTION:"@\u002Fview\u002Fuser\u002FdetailList\u002FcollectionList\u002FEDIT_COLLECTION"}},followerList:{list:[],cursor:f,hasMore:a,loading:a,skeleton:a,actionType:{FETCH:"@\u002Fview\u002Fuser\u002FdetailList\u002FfollowerList\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fuser\u002FdetailList\u002FfollowerList\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fuser\u002FdetailList\u002FfollowerList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fuser\u002FdetailList\u002FfollowerList\u002FRESET"}},followingList:{list:[],cursor:f,hasMore:a,skeleton:a,loading:a,actionType:{FETCH:"@\u002Fview\u002Fuser\u002FdetailList\u002FfollowingList\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fuser\u002FdetailList\u002FfollowingList\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fuser\u002FdetailList\u002FfollowingList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fuser\u002FdetailList\u002FfollowingList\u002FRESET"}},followingTeamsList:{list:[],cursor:f,hasMore:a,skeleton:a,loading:a,actionType:{FETCH:"@\u002Fview\u002Fuser\u002FdetailList\u002FfollowingTeamsList\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fuser\u002FdetailList\u002FfollowingTeamsList\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fuser\u002FdetailList\u002FfollowingTeamsList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fuser\u002FdetailList\u002FfollowingTeamsList\u002FRESET"}},activityList:{list:[],cursor:f,hasMore:a,loading:a,skeleton:a,actionType:{FETCH:"@\u002Fview\u002Fuser\u002FdetailList\u002FactivityList\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fuser\u002FdetailList\u002FactivityList\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fuser\u002FdetailList\u002FactivityList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fuser\u002FdetailList\u002FactivityList\u002FRESET"}},bookList:{list:[],cursor:f,skeleton:d,hasMore:a,loading:a,type:"wrote",actionType:{FETCH:"@\u002Fview\u002Fuser\u002FdetailList\u002FbookList\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fuser\u002FdetailList\u002FbookList\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fuser\u002FdetailList\u002FbookList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fuser\u002FdetailList\u002FbookList\u002FRESET"}},pinList:{list:[],hasMore:a,loading:a,skeleton:d,actionType:{FETCH:"@\u002Fview\u002Fuser\u002FdetailList\u002FpinList\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fuser\u002FdetailList\u002FpinList\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fuser\u002FdetailList\u002FpinList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fuser\u002FdetailList\u002FpinList\u002FRESET"}},courseList:{list:[],hasMore:a,loading:a,skeleton:d,actionType:{FETCH:"@\u002Fview\u002Fuser\u002FdetailList\u002FcourseList\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fuser\u002FdetailList\u002FcourseList\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fuser\u002FdetailList\u002FcourseList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fuser\u002FdetailList\u002FcourseList\u002FRESET"}},pinPraisedList:{list:[],cursor:f,hasMore:a,loading:a,skeleton:d,actionType:{FETCH:"@\u002Fview\u002Fuser\u002FdetailList\u002FpinPraisedList\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fuser\u002FdetailList\u002FpinPraisedList\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fuser\u002FdetailList\u002FpinPraisedList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fuser\u002FdetailList\u002FpinPraisedList\u002FRESET"}},eventList:{list:[],cursor:f,hasMore:a,loading:a,skeleton:a,actionType:{FETCH:"@\u002Fview\u002Fuser\u002FdetailList\u002FeventList\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fuser\u002FdetailList\u002FeventList\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fuser\u002FdetailList\u002FeventList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fuser\u002FdetailList\u002FeventList\u002FRESET"}},selfColumnList:{list:[],hasMore:a,skeleton:a,loading:a,cursor:f,actionType:{FETCH:"@\u002Fview\u002Fuser\u002FdetailList\u002FcolumnList\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fuser\u002FdetailList\u002FcolumnList\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fuser\u002FdetailList\u002FcolumnList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fuser\u002FdetailList\u002FcolumnList\u002FRESET"}},columnFollowedList:{list:[],hasMore:a,skeleton:a,loading:a,cursor:f,actionType:{FETCH:"@\u002Fview\u002Fuser\u002FdetailList\u002FcolumnFollowedList\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fuser\u002FdetailList\u002FcolumnFollowedList\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fuser\u002FdetailList\u002FcolumnFollowedList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fuser\u002FdetailList\u002FcolumnFollowedList\u002FRESET",FILTER:"@\u002Fview\u002Fuser\u002FdetailList\u002FcolumnFollowedList\u002FFILTER"}},realtimes:{list:[],cursor:f,hasMore:a,loading:a,skeleton:a,actionType:{FETCH:"@\u002Fview\u002Fuser\u002FdetailList\u002Frealtimes\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fuser\u002FdetailList\u002Frealtimes\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fuser\u002FdetailList\u002Frealtimes\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fuser\u002FdetailList\u002Frealtimes\u002FRESET",DELETE:"@\u002Fview\u002Fuser\u002FdetailList\u002Frealtimes\u002FDELETE"}},realtimeliked:{list:[],cursor:f,hasMore:a,loading:a,skeleton:a,actionType:{FETCH:"@\u002Fview\u002Fuser\u002FdetailList\u002Frealtimeliked\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fuser\u002FdetailList\u002Frealtimeliked\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fuser\u002FdetailList\u002Frealtimeliked\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fuser\u002FdetailList\u002Frealtimeliked\u002FRESET",DELETE:"@\u002Fview\u002Fuser\u002FdetailList\u002Frealtimeliked\u002FDELETE"}}}},tag:{tag:{},actionType:{FETCH:"@\u002Fview\u002Ftag\u002FFETCH",FETCH_LIST:"@\u002Fview\u002Ftag\u002FFETCH_LIST",RESET:"@\u002Fview\u002Ftag\u002FRESET"},list:{list:[],cursor:f,loading:a,skeleton:a,hasMore:a,actionType:{UPDATE_STATE:"@\u002Fview\u002Ftag\u002Flist\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Ftag\u002Flist\u002FFETCH_MORE",FETCH:"@\u002Fview\u002Ftag\u002Flist\u002FFETCH",RESET:"@\u002Fview\u002Ftag\u002Flist\u002FRESET"}}},notification:{user:{actionType:{READ_ALL:"@\u002Fview\u002Fnotification\u002Fuser\u002FREAD_ALL",RESET:"@\u002Fview\u002Fnotification\u002Fuser\u002FRESET"},listState:{list:[],cursor:f,hasMore:a,isLoading:a,messageType:z,msgTotal:b,msgSubMap:{"1":b,"2":b,"3":b,"4":b,"7":b}},list:{pageSize:h,page:g,total:b,pointer:c,lastPointer:c,list:[],loading:a,error:c,canPrev:d,canNext:d,linkList:[],lastFetchOnServer:a,actionType:{UPDATE:"@\u002Fview\u002Fnotification\u002Fuser\u002Flist\u002FUPDATE",FETCH:"@\u002Fview\u002Fnotification\u002Fuser\u002Flist\u002FFETCH",FORCE_FETCH:"@\u002Fview\u002Fnotification\u002Fuser\u002Flist\u002FFORCE_FETCH",FETCH_MORE:"@\u002Fview\u002Fnotification\u002Fuser\u002Flist\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fnotification\u002Fuser\u002Flist\u002FRESET"}}},system:{actionType:{READ_ALL:"@\u002Fview\u002Fnotification\u002Fsystem\u002FREAD_ALL",RESET:"@\u002Fview\u002Fnotification\u002Fsystem\u002FRESET"},list:{pageSize:h,page:g,total:b,pointer:c,lastPointer:c,list:[],loading:a,error:c,canPrev:d,canNext:d,linkList:[],lastFetchOnServer:a,actionType:{UPDATE:"@\u002Fview\u002Fnotification\u002Fsystem\u002Flist\u002FUPDATE",FETCH:"@\u002Fview\u002Fnotification\u002Fsystem\u002Flist\u002FFETCH",FORCE_FETCH:"@\u002Fview\u002Fnotification\u002Fsystem\u002Flist\u002FFORCE_FETCH",FETCH_MORE:"@\u002Fview\u002Fnotification\u002Fsystem\u002Flist\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fnotification\u002Fsystem\u002Flist\u002FRESET"}}}},column:{serverRenderList:a,column:{id:m},entry:{isCache:d,id:m,screenshot:t,liked:a,article_id:m,article_info:{article_id:m,user_id:A,category_id:"6809637769959178254",tag_ids:[6809640364677267000,6809640684354535000],visible_level:b,link_url:e,cover_image:"https:\u002F\u002Fp1-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002Ff31ab978043d4366901d32f5e648094d~tplv-k3u1fbpfcp-watermark.image",is_gfw:b,title:B,brief_content:C,is_english:b,is_original:g,user_index:9.573114234302912,original_type:b,original_author:e,content:D,ctime:"1627528508",mtime:E,rtime:E,draft_id:F,view_count:G,collect_count:H,digg_count:u,comment_count:b,hot_index:198,is_hot:b,rank_index:.00082019,status:j,verify_status:g,audit_status:j,mark_content:"“互斥锁”对于并发编程是必不可少的，Go语言虽然推崇使用Channel来解决对并发资源的访问，但同样实现了Sync.Mutex互斥锁供编程人员使用。有人做过专门的统计，在知名的开源软件Docker、Kubernutes、etcd、gRPC中，使用Mutex的频率是最高的。Go语言随着版本的迭代，对Sync.Mutex的实现也愈发精细化，当前版本的Sync.Mutex核心实现代码已经有100多行，其中大量使用了复杂位运算和流程控制来解决各种问题，因此使得Sync.Mutex源码达到了不可读的状态，本文从历史发展的角度剖析Sync.Mutex，希望能帮助读者读懂Sync.Mutex的源码并掌握其设计思想。\n\n## 1. 初版互斥锁——先到先得\n\ngithub地址：[初级版本的互斥锁](https:\u002F\u002Fgithub.com\u002Fgolang\u002Fgo\u002Fblob\u002Frelease.r56\u002Fsrc\u002Fpkg\u002Fsync\u002Fmutex.go)\n\n代码量很少，我们来分析一下：\n\n```\npackage sync\n\nimport (\n    \"runtime\"\n    \"sync\u002Fatomic\"\n)\n\n\n\u002F\u002F互斥锁结构\ntype Mutex struct {\n    key  int32\n    sema uint32\n}\n\n\u002F\u002F请求锁\nfunc (m *Mutex) Lock() {\n    if atomic.AddInt32(&m.key, 1) == 1 {    \u002F\u002F标识加1，如果等于1，成功获取到锁\n        return\n    }\n    runtime.Semacquire(&m.sema)     \u002F\u002F否则阻塞等待\n}\n\n\n\u002F\u002F释放锁\nfunc (m *Mutex) Unlock() {\n    switch v := atomic.AddInt32(&m.key, -1); {  \u002F\u002F标识减1\n    case v == 0:    \u002F\u002F如果等于0，则没有等待者\n        return\n    case v == -1:   \u002F\u002F如果等于-1，这种是异常情况，或者超过了最大可等待goroutine的数量\n        panic(\"sync: unlock of unlocked mutex\")\n    }\n    runtime.Semrelease(&m.sema) \u002F\u002F唤醒其他阻塞的goroutine\n}\n```\n\n初级版本的Mutex包含两个字段：\n\n![初版Mutex.png](https:\u002F\u002Fp9-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F3a73d27373684cefa3c1ae3448342999~tplv-k3u1fbpfcp-watermark.image)\n\n当goroutine调用Lock方法请求锁的时候，通过atomic.AddInt32方法原子性的给key加1，如果比较幸运，当前没有等待者，那么key的值就会等于1，成功获取到锁；如果锁已经被别的 goroutine 持有了，当前的 goroutine 会在将 key 加 1的同时，调用 runtime.Semacquire 方法，使用信号量将自己休眠，等锁释放的时候，信号量会将它唤醒。释放锁的操作也比较简单，就是原子性的给key减1，不过当减1之后值变成-1的时候，程序就会panic，例如没有请求锁，直接对锁进行释放就会panic这个错误；此外还有一种情况，**Mutex结构中的key是一个int32类型，它能表达的最大整数是40多亿，当争抢锁的goroutine数目达到这个阈值的时候，也会panic，但是这种情况在服务器资源有限的情况下，是不可能会发生的。**\n\n我们先来探讨两个问题：\n\n- 为什么请求锁时，需要使用原子操作？\n- 为什么需要信号量？它的实现机制是什么？\n\n### 1.1 原子操作的必要性\n\n我们先来看一个简单技术器程序 counter.go。\n\n```\npackage main\n\nimport (\n   \"fmt\"\n   \"sync\"\n)\n\nfunc main() {\n   \u002F\u002Fruntime.GOMAXPROCS(1)\n   var counter int64\n   var wg sync.WaitGroup\n   wg.Add(2)\n   for i := 0; i \u003C 2; i++ {\n      go func() {\n         defer wg.Done()\n         for j := 0; j \u003C 10000; j++ {\n            counter++  \u002F\u002Fatomic.AddInt64(&counter, 1)\n         }\n      }()\n   }\n   wg.Wait()\n   fmt.Println(counter)\n}\n```\n\n我们启动2个goroutine并发的累加counter，每个goroutine将counter累加1万，运行程序大概率打印出来的counter值不会是2万，而是一个小于2万的数，每次运行结果都不一样。熟悉并发编程的读者应该早都看出了端倪，这段程序中存在竞态条件。counter++不是一个原子操作，它包含三个步骤：1.读取counter变量当前值；2.对counter当前值加1，保存到寄存器临时变量中；3.将临时变量的结果再保存到counter中。其中的每一个步骤，都有对应的汇编实现。\n\n\n![竞态goroutine.png](https:\u002F\u002Fp3-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002Fa61ee5a4e61b40c88532bcb7baa8f523~tplv-k3u1fbpfcp-watermark.image)\n\n当我们使用一个CPU核心的时候(使用runtime.GOMAXPROCS(1)设置)，多次运行程序，似乎我们总能得到2万的准确计数，但是这并不是一个强保证，当我们使用```go run -race counter.go```竞态检测就大概率能检测到这段程序对counter变量的内存有非同步的并发读写：\n\n```\n==================\nWARNING: DATA RACE\nRead at 0x00c000136008 by goroutine 8:\n  main.main.func1()\n      \u002FUsers\u002Fguozhaoran\u002FgoCode\u002Fbasic\u002FgoConcurrent\u002Fmutex\u002Fexample.go:17 +0x78\n\nPrevious write at 0x00c000136008 by goroutine 7:\n  main.main.func1()\n      \u002FUsers\u002Fguozhaoran\u002FgoCode\u002Fbasic\u002FgoConcurrent\u002Fmutex\u002Fexample.go:17 +0x91\n\nGoroutine 8 (running) created at:\n  main.main()\n      \u002FUsers\u002Fguozhaoran\u002FgoCode\u002Fbasic\u002FgoConcurrent\u002Fmutex\u002Fexample.go:14 +0xe4\n\nGoroutine 7 (finished) created at:\n  main.main()\n      \u002FUsers\u002Fguozhaoran\u002FgoCode\u002Fbasic\u002FgoConcurrent\u002Fmutex\u002Fexample.go:14 +0xe4\n==================\n```\n\n所以解决方案就是使用atomic包，它非常适合于这种全局单体变量的原子性加减，而这种原子性的实现是不同的CPU架构硬件提供的能力，通过LOCK汇编指令锁定数据总线来完成。**对于Mutex的应用场景，原子操作当然是必不可少的，它保证了多个goroutine对共享变量key累加的一致性**。\n\n### 1.2 信号量\n\n信号量的概念是荷兰计算机科学家 Edsger Dijkstra 在 1963 年左右提出来的，广泛应用在不同的操作系统中。在系统中，会给每一个进程一个信号量，代表每个进程目前的状态。未得到控制权的进程，会在特定的地方被迫停下来，等待可以继续进行的信号到来。\n\nDijkstra 在他的论文中为信号量定义了两个操作 P 和 V。P 操作（descrease、wait、acquire）是减少信号量的计数值，而 V 操作（increase、signal、release）是增加信号量的计数值。使用伪代码表示如下（中括号代表原子操作）：\n\n```\nfunction V(semaphore S, integer I): \n    [S ← S + I]\n\nfunction P(semaphore S, integer I): \n    repeat: \n        [if S ≥ I: \n        S ← S − I \n        break]\n```\n\n可以看到，初始化信号量 S 有一个指定数量（n）的资源，它就像是一个有 n 个资源的池子。P 操作相当于请求资源，如果资源可用，就立即返回；如果没有资源或者不够，那么，它可以不断尝试或者阻塞等待。V 操作会释放自己持有的资源，把资源返还给信号量。信号量的值除了初始化的操作以外，只能由 P\u002FV 操作改变。\n\n现在，我们来总结下信号量的实现。初始化信号量：\n\n- 设定初始的资源的数量。\n- P 操作：将信号量的计数值减去 1，**如果新值已经为负，那么调用者会被阻塞并加入到等待队列中**。否则，调用者会继续执行，并且获得一个资源。\n- V 操作：将信号量的计数值加 1，如果先前的计数值为负，就说明有等待的 P 操作的调用者。它会从等待队列中取出一个等待的调用者，唤醒它，让它继续执行。\n\n在运行时，Go 内部使用信号量来控制 goroutine 的阻塞和唤醒。比如互斥锁的第二个字段sema，信号量的 P\u002FV 操作是通过函数实现的(Go内部运行时的信号量也是通过atomic和gopark实现的，具体实现可以看runtime\u002Fsema.go)。\n\n```\nfunc runtime_Semacquire(s *uint32)\nfunc runtime_SemacquireMutex(s *uint32, lifo bool, skipframes int)\nfunc runtime_Semrelease(s *uint32, handoff bool, skipframes int)\n```\n\n值得一提的是，**Go运行时的信号量实现的是一个优先级等待队列，这也是当前阶段Mutex饥饿模式实现的基础**。信号量的 P\u002FV 操作函数，可以将goroutine休眠后添加到优先级队列的头部或尾部；也可以从优先级队列的头部或尾部将goroutine取出唤醒。\n\n## 2. 互斥锁初步优化——给要抢锁的goroutine一次机会\n\n解读完初版互斥锁的实现，读者可能会发现一个问题，当锁被持有的情况下，新到来争抢锁的goroutine直接被运行时的信号量休眠并添加到了优先队列中，虽然这样严格保证了锁争抢的先来先得顺序，但是goroutine的休眠和唤醒非常影响性能，针对这一点，Go开发者对Mutex做了一次大的调整。\n\ngithub地址：[互斥锁进一步优化](https:\u002F\u002Fgithub.com\u002Fgolang\u002Fgo\u002Fblob\u002Fweekly.2011-07-07\u002Fsrc\u002Fpkg\u002Fsync\u002Fmutex.go)\n\n此时的Mutex结构如下:\n\n```\ntype Mutex struct {\n    state int32\n    sema  uint32\n}\n\nconst (\n    mutexLocked = 1 \u003C\u003C iota \u002F\u002F mutex is locked\n    mutexWoken\n    mutexWaiterShift = iota\n)\n```\n\nMutex结构体的key被改成了state，代表的含义也被拆分成了三个。\n\n\n![第一版优化后的Mutex.png](https:\u002F\u002Fp3-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F349de742eca64696ae55e8cb210f20ca~tplv-k3u1fbpfcp-watermark.image)\n\n- MutexLocked：state的第一个位代表锁是否被持有\n- MutexWoken：state的第二个位代表是否有唤醒的 goroutine\n- MutexWaiters：state剩下的位代表的是等待此锁的 goroutine 数\n\n在分析这个版本的代码之前，我们先来补充一个要用到的非常重要的知识点：CAS。\n\n### 2.1 自旋锁(CAS)及其实现原理\n\nCAS指令的实现原理是将给定的值与内存中的值进行比较，如果是同一个值，就用新值替换掉内存中的值，然后返回。如果不是就返回第一步的比较，因此得名“自旋锁”。下面画一个图来描述一下CAS算法，并和Go语言中的atomic.CompareAndSwap函数簇做一个比较：\n\n\n![CAS工作原理图.png](https:\u002F\u002Fp1-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F56df16fd67fe4e2782577c5abc3fd59d~tplv-k3u1fbpfcp-watermark.image)\n\n有一点需要特别注意，**CAS中值的比较与交换过程是原子性的，这个过程中如果有其他的goroutine修改了内存中的值，那么CAS会返回false**。\n\nCAS也是Mutex实现的基础，读者可能会有疑问：有了CAS为什么还要有信号量呢？**其实无论是原子操作，还是自旋锁，都不适合长时间等待的情况，因为有很多资源（数据）它有一定的时间性，你想去获取它，CPU 并不能立即返回给你，而是要等待一段时间，才能把数据返回给你。这种情况，你用自旋锁来同步访问这种资源，你会发现这是对 CPU 时间的巨大浪费。当然Mutex的实现非常适合使用CAS**。\n\n\n### 2.2 互斥锁初步优化后的Lock实现\n\n介绍完了CAS，我们来看当前版本的Lock实现，直接上代码：\n\n```\nfunc (m *Mutex) Lock() {\n    \u002F\u002F Fast path: 幸运case，能够直接获取到锁\n    if atomic.CompareAndSwapInt32(&m.state, 0, mutexLocked) {\n        return\n    }\n\n    awoke := false\n    for {\n        old := m.state\n        new := old | mutexLocked    \u002F\u002F新状态加锁\n        if old&mutexLocked != 0 {\n            new = old + 1\u003C\u003CmutexWaiterShift     \u002F\u002F等待者数量加一\n        }\n        if awoke {\n            \u002F\u002Fgoroutine是被唤醒的，新状态清除唤醒标记\n            new &^= mutexWoken\n        }\n        if atomic.CompareAndSwapInt32(&m.state, old, new) { \u002F\u002F设置新状态\n            if old&mutexLocked == 0 {   \u002F\u002F锁原状态未加锁\n                break\n            }\n            runtime.Semacquire(&m.sema)  \u002F\u002F请求信号量\n            awoke = true \u002F\u002F设置唤醒标记\n        }\n    }\n}\n```\n\n我们重点看一下对state的操作。首先通过CAS检测Mutex是否没有被goroutine持有并且没有等待者，如果是这样，那么当前goroutine很幸运，可以直接获取到锁，这也就是代码中标注的Fast path。\n\n如果当前goroutine不够幸运，那么会走到下边的循环检查阶段，for 循环不断尝试获取锁，如果获取不到，就通过 runtime.Semacquire(&m.sema) 休眠，休眠醒来之后 awoke 置为 true，尝试争抢锁。我们知道state有三个含义：\n\n- 通过```new := old | mutexLocked```设置state中的mutexLocked，给Mutex加锁；\n- 通过```new = old + 1\u003C\u003CmutexWaiterShift```给Mutex设置mutexWaiterShift，等待者加1；\n- 通过```new &^= mutexWoken```给Mutex清除Mutex的唤醒标记。\n\n那么接下来```atomic.CompareAndSwapInt32(&m.state, old, new)```执行成功说明给state设置了新值，就要区分两种情况考虑了，第一种情况是state新值中包含加锁成功了，那么直接break，goroutine抢到了锁，程序结束；否则只能说明state 只是清除 mutexWoken 标志或者增加一个 waiter 而已。\n\n这里的循环状态检查的代码有两种goroutine会同时执行：\n\n- 新来抢锁的goroutine(可能有多个)\n- 从信号量优先队列中唤醒的goroutine(最多只可能有一个)\n\n上边的描述可能比较抽象，我们结合下边的流程图帮助理解一下吧：\n\n![互斥锁争抢的原理.png](https:\u002F\u002Fp9-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F26c0382433b84652a559a2dcb8201c82~tplv-k3u1fbpfcp-watermark.image)\n\n### 2.3 互斥锁初步优化后的Unlock实现\n\nUnlock方法也变得复杂了，但是不像Lock，仔细研究一下，还是能看得懂的，下边是代码：\n\n```\nfunc (m *Mutex) Unlock() {\n    \u002F\u002F Fast path: drop lock bit.\n    new := atomic.AddInt32(&m.state, -mutexLocked)  \u002F\u002F去掉锁状态\n    if (new+mutexLocked)&mutexLocked == 0 {     \u002F\u002F未被锁定的mutex释放锁会panic\n        panic(\"sync: unlock of unlocked mutex\")\n    }\n\n    old := new\n    for {\n        \u002F\u002F锁上没有goroutine等待或者有被唤醒的goroutine,或者又被别的goroutine加了锁,那么不需要做任何事情，返回即可\n        if old\u003E\u003EmutexWaiterShift == 0 || old&(mutexLocked|mutexWoken) != 0 {\n            return\n        }\n        \u002F\u002F将mutexWaiterShift数量减1并设置mutexWoken为true\n        new = (old - 1\u003C\u003CmutexWaiterShift) | mutexWoken\n        if atomic.CompareAndSwapInt32(&m.state, old, new) {     \u002F\u002FCAS设置成功，唤醒一个新的goroutine争抢锁即可\n            runtime.Semrelease(&m.sema)\n            return\n        }\n        old = m.state   \u002F\u002F记录当前mutex的状态，继续循环\n    }\n}\n```\n\nUnlock方法先定义一个新变量将锁标志去掉，如果对一个未加锁的Mutex进行Unlock会panic，然后程序还需要进行一些额外的判断，并不能直接返回。下面情况之一调用Unlock的goroutine可以直接返回：\n\n- Mutex上没有waiter\n- Mutex又被别人上了锁\n- 有goroutine被唤醒了\n\n否则，先设置Mutex中mutexWaiterShift减1，并标记mutexWoken为true，使用CAS方法如果设置成功，则从信号量的优先队列中唤醒一个goroutine，程序返回。否则记录当前mutex的状态，继续循环判断。直到返回为止。\n\n相比较最初版本的设计，这个版本的Sync.Mutex实现主要是给新来的goroutine一次获取到锁的机会，打破了原来先来先得的逻辑，代码的复杂度也增加了不少。\n\n## 3. 互斥锁进一步优化——给要抢锁的goroutine更多机会\n\n我们前边对Sync.Mutex的优化是基于一种猜想：新来的争抢锁的goroutine很大概率上能够获取到锁！持有锁的goroutine在持有锁时间越短的情况下，这种概率越大，那么我们为什么不给争抢锁的goroutine更多机会呢？也就是让它们稍微等一会，如果等一会也获取不到，那么就乖乖的添加进信号量的优先队列就好了。实际上，Go官方团队也是这么做的。\n\ngihub地址：[给要抢锁的goroutine更多机会](https:\u002F\u002Fgithub.com\u002Fgolang\u002Fgo\u002Fblob\u002Fgo1.5\u002Fsrc\u002Fsync\u002Fmutex.go)\n\n我们来看一下代码：\n\n```\nfunc (m *Mutex) Lock() {\n    \u002F\u002F Fast path: 幸运case，能够直接获取到锁\n    if atomic.CompareAndSwapInt32(&m.state, 0, mutexLocked) {\n        return\n    }\n\n    awoke := false\n    iter := 0\n    for {   \u002F\u002F 不管是新来的请求锁的goroutine, 还是被唤醒的goroutine，都不断尝试请求锁\n        old := m.state\n        new := old | mutexLocked    \u002F\u002F新状态加锁\n        if old&mutexLocked != 0 {   \u002F\u002F 锁还没被释放\n            if runtime_canSpin(iter) {  \u002F\u002F 还可以自旋\n                if !awoke && old&mutexWoken == 0 && old\u003E\u003EmutexWaiterShift != 0 &&\n                    atomic.CompareAndSwapInt32(&m.state, old, old|mutexWoken) {\n                    awoke = true\n                }\n                runtime_doSpin()\n                iter++\n                continue    \u002F\u002F自旋，再次尝试获取锁\n            }\n            new = old + 1\u003C\u003CmutexWaiterShift      \u002F\u002F等待者数量加一\n        }\n        if awoke {  \u002F\u002F唤醒状态，去掉标记\n            new &^= mutexWoken\n        }\n        if atomic.CompareAndSwapInt32(&m.state, old, new) { \u002F\u002F设置新状态\n            if old&mutexLocked == 0 {   \u002F\u002F锁原状态未加锁\n                break\n            }\n            runtime_Semacquire(&m.sema) \u002F\u002F请求信号量\n            awoke = true    \u002F\u002F设置信号量\n            iter = 0    \u002F\u002F重新设置自旋计数器\n        }\n    }\n}\n```\n\n这次的优化很小，只增加了runtime_canSpin的检测，有一个自旋计数器iter，如果抢锁的goroutine还能自旋的话，就自旋等待持有锁的goroutine释放锁，这样能够增大抢到锁的概率。\n\n我想读者应该对代码中的这部分很迷惑：\n\n```\nif !awoke && old&mutexWoken == 0 && old\u003E\u003EmutexWaiterShift != 0 &&\n                    atomic.CompareAndSwapInt32(&m.state, old, old|mutexWoken) {\n                    awoke = true\n                }\n```\n\n这四个&&符号确实让人眼花撩乱，不过结合上一小节对Sync.Mutex的解读，我们能分析出这段代码的用途。首先&&是短路运算符，有一个为false判断就不会进行下去了。```!awoke```表示程序逻辑是由新加入抢锁的goroutine进来的，而不是从sema优先级队列中唤醒的goroutine进来的；再然后如果Mutex的旧值是没有唤醒新的goroutine(```old&mutexWoken == 0```)的并且有等待者(```old\u003E\u003EmutexWaiterShift != 0```)的话，就尝试通过CAS给Mutex设置一个唤醒标记(```atomic.CompareAndSwapInt32(&m.state, old, old|mutexWoken)```)，如果成功的话，将awoke设置为true，这样做可以让调用Unlock的goroutine快速返回，而不用从优先队列中再唤醒goroutine来争抢锁。\n\n经过这一版本的优化，我们可以看到，**Sync.Mutex对新加入抢锁的goroutine相当友好，表面上看这样似乎没有什么问题，能够让更多的goroutine在最短的时间内获取到锁。但是我们考虑一下那些一直在信号量优先队列中的等待者怎么办？锁有可能一直被新来的goroutine抢到，这就产生了“饥饿问题”**。\n\n## 4.终极版本的互斥锁——小康社会，不再饥饿\n\nSync.Mutex的“饥饿问题”早在Go 1.9版本中就解决了，后续也进行了一些优化工作，到此Sync.Mutex才算是实现的比较完美。我们接下来会解读当前最新版本Go1.17的代码实现，读者要和我一起开启烧脑模式，细细的品一品了。\n\ngithub地址：[终极版本的Sync.Mutex](https:\u002F\u002Fgithub.com\u002Fgolang\u002Fgo\u002Fblob\u002Fgo1.17rc1\u002Fsrc\u002Fsync\u002Fmutex.go)\n\n### 4.1 Mutex结构体实现\n\n为了解决饥饿问题，Mutex结构体从state字段中又分出一个位标识当前Mutex是否饥饿，并定义了一个常量，将获取锁的goroutine等待时间设置了 1 毫秒阈值。\n\n![终极版本的Mutex.png](https:\u002F\u002Fp3-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002Faac838c01ab04e3792b29c4736435b23~tplv-k3u1fbpfcp-watermark.image)\n\n```\ntype Mutex struct {\n    state int32\n    sema  uint32\n}\n\nconst (\n    mutexLocked = 1 \u003C\u003C iota \u002F\u002F mutex is locked\n    mutexWoken\n    mutexStarving   \u002F\u002F 从state字段中分出一个饥饿标记\n    mutexWaiterShift = iota\n\n    starvationThresholdNs = 1e6   \u002F\u002F1000000ns = 1ms\n)\n```\n\n### 4.2 Sync.Mutex 终极版本的Lock函数实现\n\n最新版本的Sync.Mutex的Lock方法和Unlock方法将fast path 和slow path拆成独立的函数，以便内联，提高性能。本节我们先来看一下Lock方法的实现：\n\n```\nfunc (m *Mutex) Lock() {\n\t\u002F\u002F Fast path: 顺利的获取到锁\n\tif atomic.CompareAndSwapInt32(&m.state, 0, mutexLocked) {\n\t\tif race.Enabled {\n\t\t\trace.Acquire(unsafe.Pointer(m))\n\t\t}\n\t\treturn\n\t}\n\t\u002F\u002F Slow path (缓慢之路，通过自旋、竞争或者饥饿状态下的锁竞争)\n\tm.lockSlow()\n}\n\nfunc (m *Mutex) lockSlow() {\n\tvar waitStartTime int64\n\tstarving := false       \u002F\u002F标识当前goroutine是否饥饿\n\tawoke := false  \u002F\u002F唤醒标记\n\titer := 0   \u002F\u002F自旋次数\n\told := m.state  \u002F\u002F当前的锁状态\n\tfor {\n\t\t\u002F\u002F锁是非饥饿状态，并且未释放，尝试自旋\n\t\tif old&(mutexLocked|mutexStarving) == mutexLocked && runtime_canSpin(iter) {\n\t\t\t\u002F\u002F 主动自旋的场景\n\t\t\t\u002F\u002F 尝试设置 mutexWoken 标志以通知 Unlock 不唤醒其他阻塞的 goroutine\n\t\t\tif !awoke && old&mutexWoken == 0 && old\u003E\u003EmutexWaiterShift != 0 &&\n\t\t\t\tatomic.CompareAndSwapInt32(&m.state, old, old|mutexWoken) {\n\t\t\t\tawoke = true\n\t\t\t}\n\t\t\truntime_doSpin()    \u002F\u002F自旋\n\t\t\titer++\n\t\t\told = m.state\n\t\t\tcontinue\n\t\t}\n\t\tnew := old\n\t\t\u002F\u002F 不要尝试获取饥饿的互斥锁，新到达的 goroutine 必须排队\n\t\tif old&mutexStarving == 0 {\n\t\t\tnew |= mutexLocked  \u002F\u002F非饥饿状态，加锁\n\t\t}\n\t\tif old&(mutexLocked|mutexStarving) != 0 {   \u002F\u002F饥饿状态，或者锁被抢占，等待者 + 1\n\t\t\tnew += 1 \u003C\u003C mutexWaiterShift\n\t\t}\n\t\t\u002F\u002F 当前 goroutine 将互斥锁切换到饥饿模式。\n\t\tif starving && old&mutexLocked != 0 {\n\t\t\tnew |= mutexStarving\n\t\t}\n\t\tif awoke {\n\t\t\t\u002F\u002F清除awoke标识\n\t\t\tnew &^= mutexWoken\n\t\t}\n\t\tif atomic.CompareAndSwapInt32(&m.state, old, new) {\n\t\t\tif old&(mutexLocked|mutexStarving) == 0 {\n\t\t\t\tbreak \u002F\u002F 上锁成功\n\t\t\t}\n\t\t\t\u002F\u002F 第一次等待，添加到信号量队列的队首\n\t\t\tqueueLifo := waitStartTime != 0\n\t\t\tif waitStartTime == 0 {\n\t\t\t\twaitStartTime = runtime_nanotime()\n\t\t\t}\n\t\t\truntime_SemacquireMutex(&m.sema, queueLifo, 1)\n            \u002F\u002F设置饥饿标记\n\t\t\tstarving = starving || runtime_nanotime()-waitStartTime \u003E starvationThresholdNs\n\t\t\told = m.state\n\t\t\tif old&mutexStarving != 0 {\n\t\t\t\t\u002F\u002F加锁并将waiter数量减1\n\t\t\t\tdelta := int32(mutexLocked - 1\u003C\u003CmutexWaiterShift)\n\t\t\t\tif !starving || old\u003E\u003EmutexWaiterShift == 1 {\n\t\t\t\t\t\u002F\u002F非饥饿状态的goroutine,最后一个waiter已经不饥饿了，清除标记\n\t\t\t\t\tdelta -= mutexStarving\n\t\t\t\t}\n\t\t\t\tatomic.AddInt32(&m.state, delta)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tawoke = true\n\t\t\titer = 0\n\t\t} else {\n\t\t\told = m.state\n\t\t}\n\t}\n}\n```\n\n代码结合注释也很难看懂，再结合流程图看一下。\n\n\n![Mutex抢锁大致流程 (1).png](https:\u002F\u002Fp3-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F492caf4e05f04a609bc3f0b2ba6be10d~tplv-k3u1fbpfcp-watermark.image)\n\n获取锁的goroutine很幸运的话，可以通过Fast path很快获取锁，我们来一步步分析一下lockSlow函数的实现。\n首先定义了当前goroutine用到的一些变量信息，然后使用old保存当前锁的状态。\n\n```\nvar waitStartTime int64\n\tstarving := false   \u002F\u002F标识当前goroutine是否饥饿模式\n\tawoke := false  \u002F\u002F唤醒标记，初次进入for循环为false，之后以从sema优先队列中唤醒的身份进入for循环\n\titer := 0   \u002F\u002F自旋次数，用来判断是否可以继续自旋获取锁\nold := m.state  \u002F\u002F当前的锁状态        \n```\n\n然后代码就进入到了for循环，**lockSlow的实现效果是尽可能少的循环，但是一定使获取锁的goroutine得到锁**。for循环中，当前抢锁的goroutine发现锁还没有被释放(正常模式下)，则调用runtime_canSpin自旋等待一会，期望锁能够被释放，这期间，程序还做了其他一些事情，比如通过设置Mutex的awoke状态，尽量使得Unlock程序不要再唤醒sema优先队列中的goroutine了，因为参与竞争锁的goroutine越多，得到锁的概率越小！\n\n```\n\tfor {\n\t\t\u002F\u002F锁是非饥饿状态，并且未释放，尝试自旋\n\t\tif old&(mutexLocked|mutexStarving) == mutexLocked && runtime_canSpin(iter) {\n\t\t\t\u002F\u002F 主动自旋的场景\n\t\t\t\u002F\u002F 尝试设置 mutexWoken 标志以通知 Unlock 不唤醒其他阻塞的 goroutine\n\t\t\tif !awoke && old&mutexWoken == 0 && old\u003E\u003EmutexWaiterShift != 0 &&\n\t\t\t\tatomic.CompareAndSwapInt32(&m.state, old, old|mutexWoken) {\n\t\t\t\tawoke = true\n\t\t\t}\n\t\t\truntime_doSpin()    \u002F\u002F自旋\n\t\t\titer++\n\t\t\told = m.state\n\t\t\tcontinue\n\t\t}\n```\n\n自旋等待之后，获取锁的goroutine命运有两个：\n\n- 当前锁已经被释放了，那么它就可以参与竞争了\n- 当前锁没有被释放，又或者它参与锁竞争失败了，那么它就要进入sema的优先队列了\n\n不过不管结果如何，它都要走下边的通用逻辑，就是给Mutex设置新状态。有下边几个步骤：\n\n- 判断锁的状态是否是正常模式，是的话就设置mutexLocked标志准备抢锁\n- 如果锁的状态是没有被释放，或者是饥饿模式的话，当前goroutine一定要进sema优先队列了，这时候设置锁的等待者+1\n- 如果锁已经被标记为饥饿模式了，并且原来锁并没有被释放，那么将锁给打上饥饿的标记。有的读者可能会问了，为什么只有锁没有被释放的时候才打上饥饿标记呢？这是因为Unlock方法是根据锁是否为饥饿模式来从sema优先队列中唤醒goroutine的，也就是**锁为饥饿模式时，优先队列中必须还有等待的goroutine**。\n- 如果有awoke标记的话，将锁上的mutexWoken标记给擦除掉，因为不管当前goroutine最终进入sema优先队列还是获取到锁，新状态都应该清楚awoke标记。\n\n\n```\n                new := old\n\t\t\u002F\u002F 不要尝试获取饥饿的互斥锁，新到达的 goroutine 必须排队\n\t\tif old&mutexStarving == 0 {\n\t\t\tnew |= mutexLocked  \u002F\u002F非饥饿状态，加锁\n\t\t}\n\t\tif old&(mutexLocked|mutexStarving) != 0 {   \u002F\u002F饥饿状态，或者锁被抢占，等待者 + 1\n\t\t\tnew += 1 \u003C\u003C mutexWaiterShift\n\t\t}\n\t\t\u002F\u002F 当前 goroutine 将互斥锁切换到饥饿模式。\n\t\tif starving && old&mutexLocked != 0 {\n\t\t\tnew |= mutexStarving\n\t\t}\n\t\tif awoke {\n\t\t\t\u002F\u002F清除awoke标识\n\t\t\tnew &^= mutexWoken\n\t\t}\n```\n\n设置状态的步骤走完了，接下来就是CAS了，有两个结局：CAS成功 or CAS失败。**失败是成功之母，CAS失败记录当前锁的状态，再次走for循环就好了，注意这时候不用更新spin计数，因为抢锁失败并没有进入sema优先队列**！当然CAS成功了也并不是万事大吉了，如果锁是在正常情况下被上锁成功的话，那么恭喜当前goroutine成功获取到了锁；否则是一定要进入sema优先队列的，但是具体是被插入到头部还是尾部，则要分情况而定，这时候waitStartTime就发挥作用了，根据它不仅能判断出来抢锁的goroutine是否是第一次要被插入sema优先队列，还能判断当前锁状态是否已经达到饥饿阈值了。\n\n我们先来说goroutine是否是第一次要被插入sema优先队列的情况，是插入到尾部，这样只能等到下一轮调度唤醒了；如果当前goroutine不是第一次插入到sema优先队列，程序会将它插入到头部，这样下一个唤醒的依然是它，增加了它获取到锁的概率！\n\n计算当前锁状态模式的代码是goroutine从sema优先队列中被唤醒之后，根据waitStartTime的记录和上边starving的标识，如果当前goroutine等待锁时间超过了1ms，那么当前goroutine就会将锁标记为饥饿(注意这个时候并没有给Mutex打上饥饿的标识，只是标记为饥饿，如果接下来当前goroutine仍然获取不到锁，那么接下来的循环中会做这个事情)。这个时候再次判断锁的状态，如果锁为饥饿模式，那么就直接把锁交给当前请求锁的goroutine就好了，否则当前被唤醒的goroutine只能进行新一轮抢锁了(重新设置自旋计数器)。\n\n```\nif atomic.CompareAndSwapInt32(&m.state, old, new) {\n\t\t\tif old&(mutexLocked|mutexStarving) == 0 {\n\t\t\t\tbreak \u002F\u002F 上锁成功\n\t\t\t}\n\t\t\t\u002F\u002F 第一次等待，添加到信号量队列的队首\n\t\t\tqueueLifo := waitStartTime != 0\n\t\t\tif waitStartTime == 0 {\n\t\t\t\twaitStartTime = runtime_nanotime()\n\t\t\t}\n\t\t\truntime_SemacquireMutex(&m.sema, queueLifo, 1)\n            \u002F\u002F设置饥饿标记\n\t\t\tstarving = starving || runtime_nanotime()-waitStartTime \u003E starvationThresholdNs\n\t\t\told = m.state\n\t\t\tif old&mutexStarving != 0 {\n\t\t\t\t\u002F\u002F加锁并将waiter数量减1\n\t\t\t\tdelta := int32(mutexLocked - 1\u003C\u003CmutexWaiterShift)\n\t\t\t\tif !starving || old\u003E\u003EmutexWaiterShift == 1 {\n\t\t\t\t\t\u002F\u002F非饥饿状态的goroutine,最后一个waiter已经不饥饿了，清除标记\n\t\t\t\t\tdelta -= mutexStarving\n\t\t\t\t}\n\t\t\t\tatomic.AddInt32(&m.state, delta)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tawoke = true\n\t\t\titer = 0\n\t\t} else {\n\t\t\told = m.state\n\t\t}\n```\n\n以上就是终极版本Mutex的Lock函数实现，接下来回答几个常见问题：\n\n- 1. 如果Mutex已经被标记成为“饥饿模式”了，什么时候会变为“正常模式”呢？\n\n拥有 Mutex 的 waiter 发现下面两种情况的其中之一，它就会把这个 Mutex 转换成正常模式；第一此 waiter 已经是队列中的最后一个 waiter 了(通过代码```!starving || old\u003E\u003EmutexWaiterShift == 1```判断)，没有其它的等待锁的 goroutine 了；第二是此 waiter 的等待时间小于 1 毫秒(通过代码```starving = starving || runtime_nanotime()-waitStartTime \u003E starvationThresholdNs```判断)。\n\n- 2. 为什么要有饥饿模式？\n\n饥饿模式是对公平性和性能的一种平衡，它避免了某些 goroutine 长时间的等待锁。在饥饿模式下，优先对待的是那些一直在等待的 waiter。正常模式拥有更好的性能，因为即使有等待抢锁的 waiter，goroutine 也可以连续多次获取到锁。\n\n- 3. 饥饿模式下Mutex是如何工作的?\n\n饥饿模式下，会直接把锁交给队列第一个 goroutine。这块再代码中有体现。\n\n本节内容建议读着多读几遍，最好是从文章开始顺着历史发展的脉络思考，如果还有什么问题，可以在留言区和我一块交流。\n\n我们再接着看Unlock方法。\n\n\n### 4.3 Sync.Mutex 终极版本的Unlock函数实现\n\n相对于Lock函数，Unlock函数的代码逻辑比较好理解，我们先看一下流程图：\n\n\n![Mutex释放锁大致流程.png](https:\u002F\u002Fp6-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002Fe556320ebcdf45ecb1d240f10ff341a2~tplv-k3u1fbpfcp-watermark.image)\n\n\n代码如下：\n\n```\nfunc (m *Mutex) Unlock() {\n\t\u002F\u002F Fast path: 将锁标记去掉\n\tnew := atomic.AddInt32(&m.state, -mutexLocked)\n\tif new != 0 {   \u002F\u002F还需要做其他的事\n\t\tm.unlockSlow(new)\n\t}\n}\n\nfunc (m *Mutex) unlockSlow(new int32) {\n    \u002F\u002F无锁的mutex释放锁会panic\n\tif (new+mutexLocked)&mutexLocked == 0 {\n\t\tthrow(\"sync: unlock of unlocked mutex\")\n\t}\n\tif new&mutexStarving == 0 {\n\t\told := new\n\t\tfor {\n\t\t\t\u002F\u002F锁上没有goroutine等待或者有被唤醒的goroutine改变了锁的状态，直接return即可\n\t\t\tif old\u003E\u003EmutexWaiterShift == 0 || old&(mutexLocked|mutexWoken|mutexStarving) != 0 {\n\t\t\t\treturn\n\t\t\t}\n\t\t\t\u002F\u002F 减少等待者并设置Mutex唤醒标记，CAS释放锁\n\t\t\tnew = (old - 1\u003C\u003CmutexWaiterShift) | mutexWoken\n\t\t\tif atomic.CompareAndSwapInt32(&m.state, old, new) {\n\t\t\t\truntime_Semrelease(&m.sema, false, 1)   \u002F\u002F锁在正常模式下从sema优先队列尾部唤醒新的goroutine\n\t\t\t\treturn\n\t\t\t}\n\t\t\told = m.state\n\t\t}\n\t} else {\n\t\t\u002F\u002F饥饿模式下，从优先队列的头部唤醒等待的goroutine，Lock方法会直接将锁给它\n\t\truntime_Semrelease(&m.sema, true, 1)\n\t}\n}\n```\n\n先将锁标记去掉，但是state其他字段并不为0的话，还需要做一些额外的工作，这就是```unlockSlow```的代码逻辑，如果是饥饿模式的话，从优先队列的头部唤醒一个goroutine，分析Lock代码的时候我们知道，饥饿模式下会将锁直接给这个唤醒的goroutine; 正常模式下进入for循环，如果锁的的其他状态已经被改变的情况下，unlockSlow什么也不需要做，return即可，否则将锁等待者数量-1，并设置唤醒标识，CAS操作成功之后，从sema优先队列尾部唤醒一个goroutine参与到抢锁工作中。\n\n以上就是Sync.Mutex终极版本的全部实现了。下边我们再来看一下Sync.Mutex使用中都有哪些坑。\n\n## 5. Sync.Mutex使用时常见的坑\n\n关于Mutex的使用，一不小心就会产生死锁或者panic，使用不得当会有很大的性能开销，接下来我们结合上边的源码分析一下。\n\n- Mutex对goroutine无状态性\n\n看过源代码，我们不难看出不同的goroutine操作Mutex这一个全局变量是没有状态记录的，这样会出现两种情况：1.一个goroutine可以释放掉另一个goroutine的锁；2.goroutine一旦重入设置两次Lock，就会死锁；建议使用Mutex时，Lock\u002FUnlock要成对出现，最好是封装到一个函数中，使用defer是一个好的方案。也可以对Mutex的无状态性做一个封装，例如实现锁的重入，添加一些锁的检测机制等等。\n\n- Mutex 千万不能被复制\n\n这里所说的千万不能被复制并不是Go语言在语法上做了限制，而是在使用过程中，为了避免不必要的麻烦，不要拷贝Mutex，从源码分析我们看到，Mutex可以被千千万万个goroutine使用，拷贝Mutex时，只是拷贝的一个临时状态而已。复制之后，一个新 Mutex 可能莫名处于持有锁、唤醒或者饥饿状态，甚至等阻塞等待数量远远大于0。而原锁 Unlock 的时候，却不会影响复制锁。\n\n关于锁复制后产生的严重后果，推荐阅读：[当 Go struct 遇上 Mutex](https:\u002F\u002Fmp.weixin.qq.com\u002Fs\u002FOYGVR0d-fq1hgOvrdsUnYA)\n\n- 产生强烈的锁竞争时怎么办\n\n当线上QPS很高时，如果使用了Mutex，可能会发现大量的goroutine阻塞在Mutex的Lock函数上，这个时候就要想办法优化程序，首先应该尽量少使用Mutex，如果非要使用，可以采用分片管理数据的方式，Mutex保护的程序逻辑不应该过于复杂，因为大量goroutine阻塞在Mutex的Lock函数上会产生饥饿，饥饿带来的问题是性能更差，不能更快的恢复到正常模式将是一场灾难。\n\n关于锁竞争的优化，推荐阅读：[一次错误使用 go-cache 导致出现的线上问题](https:\u002F\u002Fmp.weixin.qq.com\u002Fs\u002FtcsSgCRj-tBDD7qyq53IAw)\n\n## 6. 小结\n\nDDD设计中有关战略模型的分析指出，每一个复杂系统都有一个演进的过程，我们不要期望一次就将它做的很好。我觉得这个观点应用在Go语言的Sync.Mutex设计上非常恰当，“罗马不是一天建成的”，我们不得不佩服Sync.Mutex开发者的匠心精神，一次次打磨，精益求精的实现了现在的Sync.Mutex，虽然它可能还不够完美，还能够继续雕琢，但是这个发现问题并解决问题的思路和精神，是我们应该学习的。本文还分析了很多关于Sync.Mutex实现的基础知识：原子性、信号量、CAS；还指出了使用Mutex时应该注意的问题，希望感兴趣的读者在留言区继续和我交流！\n\n\n**Reference:**\n\n- Mutex 源码分析:\nhttps:\u002F\u002Fcolobu.com\u002F2018\u002F12\u002F18\u002Fdive-into-sync-mutex\u002F\n\n- 原子操作是如何实现的\nhttps:\u002F\u002Fgithub.com\u002Fluohaha\u002FMyBlog\u002Fissues\u002F3\n\n- 百度百科：信号量\nhttps:\u002F\u002Fbaike.baidu.com\u002Fitem\u002F%E4%BF%A1%E5%8F%B7%E9%87%8F\u002F9807501\n\n- 一文彻底搞懂CAS实现原理\nhttps:\u002F\u002Fzhuanlan.zhihu.com\u002Fp\u002F94762520\n\n- Go sync.Mutex 深入不浅出\nhttps:\u002F\u002Fjuejin.cn\u002Fpost\u002F6984980411008958471\u002F#heading-10\n\n- 一次错误使用 go-cache 导致出现的线上问题\nhttps:\u002F\u002Fmp.weixin.qq.com\u002Fs\u002FtcsSgCRj-tBDD7qyq53IAw\n\n- 当 Go struct 遇上 Mutex\nhttps:\u002F\u002Fmp.weixin.qq.com\u002Fs\u002FOYGVR0d-fq1hgOvrdsUnYA\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",display_count:b,is_markdown:g,app_html_content:e},author_user_info:{user_id:A,user_name:I,company:"百度",job_title:"后端开发工程师",avatar_large:"https:\u002F\u002Fp3-passport.byteacctimg.com\u002Fimg\u002Fuser-avatar\u002Fce5ce2f18b2ab595a782ac86c8883f9b~300x300.image",level:J,description:"我愿化身石桥，忍受五百年风吹、雨打、日晒，等你走过......",followee_count:38,follower_count:401,post_article_count:21,digg_article_count:14,got_digg_count:482,got_view_count:106773,post_shortmsg_count:b,digg_shortmsg_count:b,isfollowed:a,favorable_author:b,power:K,study_point:b,university:{university_id:f,name:e,logo:e},major:{major_id:f,parent_id:f,name:e},student_status:b,select_event_count:b,select_online_course_count:b,identity:b,is_select_annual:a,select_annual_rank:b,annual_list_type:b,extraMap:{},is_logout:b,annual_info:[],account_amount:b,user_growth_info:{user_id:2101921964623992,jpower:K,jscore:131,jpower_level:J,jscore_level:z,jscore_title:"新星掘友",author_achievement_list:[],vip_level:g,vip_title:"初学乍练",jscore_next_level_score:150,jscore_this_level_mini_score:30},is_vip:a,become_author_days:b,collection_set_article_count:b,recommend_article_count_daily:b,article_collect_count_daily:b},category:{category_id:"6809637769959178254",category_name:"后端",category_url:"backend",rank:g,back_ground:"https:\u002F\u002Flc-mhke0kuv.cn-n1.lcfile.com\u002Ffb3b208d06e6fe32.png",icon:"https:\u002F\u002Flc-mhke0kuv.cn-n1.lcfile.com\u002Fa2ec01b816abd4c5.png",ctime:1457483880,mtime:1432503193,show_type:z,item_type:j,promote_tag_cap:J,promote_priority:g,id:"6809637769959178254",name:"后端",title:"后端",alias:"backend"},tags:[{entriesCount:t,subscribed:a,id:"6809640364677267469",tag_id:"6809640364677267469",tag_name:"Go",color:e,icon:"https:\u002F\u002Fp1-jj.byteimg.com\u002Ftos-cn-i-t2oaga2asx\u002Fleancloud-assets\u002F1aae38ab22d12b654cfa.png~tplv-t2oaga2asx-image.image",back_ground:e,show_navi:b,ctime:1432234497,mtime:1679222705,id_type:9,tag_alias:"golang,go,Go",post_article_count:18387,concern_user_count:110370,title:"Go",tagId:"6809640364677267469",articleCount:18387,subscribersCount:110370,createdAt:c,updatedAt:c},{entriesCount:t,subscribed:a,id:"6809640684354535432",tag_id:"6809640684354535432",tag_name:"源码",color:"#000000",icon:"https:\u002F\u002Fp1-jj.byteimg.com\u002Ftos-cn-i-t2oaga2asx\u002Fgold-user-assets\u002F1550744852177428affe45c5925b2ef20f04344f3bea9.jpg~tplv-t2oaga2asx-image.image",back_ground:e,show_navi:b,ctime:1480290794,mtime:1679228447,id_type:9,tag_alias:e,post_article_count:6154,concern_user_count:77506,title:"源码",tagId:"6809640684354535432",articleCount:6154,subscribersCount:77506,createdAt:c,updatedAt:c}],user_interact:{id:6990181431574004000,omitempty:j,user_id:4200566397614631,is_digg:a,is_follow:a,is_collect:a,collect_set_count:b},org:{org_info:c,org_user:c,is_followed:a},req_id:"202303192034512318436B7B7BCA5C16A5",status:{push_status:b},author_interact:c,extra:{boost_type:e},title:B,user:L,viewCount:t,commentsCount:b,isEvent:t,abstract:C,latestCommentAt:c,createdAt:new Date(1627528508000),updatedAt:c,isTopicEvent:a,likedCount:u,likeCount:u,content:D,originalUrl:e,type:"post",collected:a,viewsCount:G,username:I,viewerHasLiked:a,draftId:F,collectionCount:H},entryView:{},author:L,adEntryList:[],relatedEntryList:[],linkVotingList:[],userAnnuals:[],columnList:[],resultHtml:"\u003Cstyle\u003E.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre\u003Ecode{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:\"\"}.markdown-body blockquote\u003Ep{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}\u003C\u002Fstyle\u003E\u003Cstyle data-highlight data-highlight-key=\"juejin\"\u003E.markdown-body pre,.markdown-body pre\u003Ecode.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}\u003C\u002Fstyle\u003E\u003Cp\u003E“互斥锁”对于并发编程是必不可少的，Go语言虽然推崇使用Channel来解决对并发资源的访问，但同样实现了Sync.Mutex互斥锁供编程人员使用。有人做过专门的统计，在知名的开源软件Docker、Kubernutes、etcd、gRPC中，使用Mutex的频率是最高的。Go语言随着版本的迭代，对Sync.Mutex的实现也愈发精细化，当前版本的Sync.Mutex核心实现代码已经有100多行，其中大量使用了复杂位运算和流程控制来解决各种问题，因此使得Sync.Mutex源码达到了不可读的状态，本文从历史发展的角度剖析Sync.Mutex，希望能帮助读者读懂Sync.Mutex的源码并掌握其设计思想。\u003C\u002Fp\u003E\n\u003Ch2 data-id=\"heading-0\"\u003E1. 初版互斥锁——先到先得\u003C\u002Fh2\u003E\n\u003Cp\u003Egithub地址：\u003Ca href=\"https:\u002F\u002Flink.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgolang%2Fgo%2Fblob%2Frelease.r56%2Fsrc%2Fpkg%2Fsync%2Fmutex.go\" target=\"_blank\" title=\"https:\u002F\u002Fgithub.com\u002Fgolang\u002Fgo\u002Fblob\u002Frelease.r56\u002Fsrc\u002Fpkg\u002Fsync\u002Fmutex.go\" ref=\"nofollow noopener noreferrer\"\u003E初级版本的互斥锁\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E代码量很少，我们来分析一下：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs language-go copyable\" lang=\"go\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Epackage\u003C\u002Fspan\u003E sync\n\n\u003Cspan class=\"hljs-keyword\"\u003Eimport\u003C\u002Fspan\u003E (\n    \u003Cspan class=\"hljs-string\"\u003E\"runtime\"\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-string\"\u003E\"sync\u002Fatomic\"\u003C\u002Fspan\u003E\n)\n\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F互斥锁结构\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Etype\u003C\u002Fspan\u003E Mutex \u003Cspan class=\"hljs-keyword\"\u003Estruct\u003C\u002Fspan\u003E {\n    key  \u003Cspan class=\"hljs-type\"\u003Eint32\u003C\u002Fspan\u003E\n    sema \u003Cspan class=\"hljs-type\"\u003Euint32\u003C\u002Fspan\u003E\n}\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F请求锁\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunc\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-params\"\u003E(m *Mutex)\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E Lock() {\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E atomic.AddInt32(&#x26;m.key, \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E) == \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E {    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F标识加1，如果等于1，成功获取到锁\u003C\u002Fspan\u003E\n        \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E\n    }\n    runtime.Semacquire(&#x26;m.sema)     \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F否则阻塞等待\u003C\u002Fspan\u003E\n}\n\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F释放锁\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunc\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-params\"\u003E(m *Mutex)\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E Unlock() {\n    \u003Cspan class=\"hljs-keyword\"\u003Eswitch\u003C\u002Fspan\u003E v := atomic.AddInt32(&#x26;m.key, \u003Cspan class=\"hljs-number\"\u003E-1\u003C\u002Fspan\u003E); {  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F标识减1\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Ecase\u003C\u002Fspan\u003E v == \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E:    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F如果等于0，则没有等待者\u003C\u002Fspan\u003E\n        \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Ecase\u003C\u002Fspan\u003E v == \u003Cspan class=\"hljs-number\"\u003E-1\u003C\u002Fspan\u003E:   \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F如果等于-1，这种是异常情况，或者超过了最大可等待goroutine的数量\u003C\u002Fspan\u003E\n        \u003Cspan class=\"hljs-built_in\"\u003Epanic\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E\"sync: unlock of unlocked mutex\"\u003C\u002Fspan\u003E)\n    }\n    runtime.Semrelease(&#x26;m.sema) \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F唤醒其他阻塞的goroutine\u003C\u002Fspan\u003E\n}\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E初级版本的Mutex包含两个字段：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fp9-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F3a73d27373684cefa3c1ae3448342999~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"初版Mutex.png\" loading=\"lazy\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E当goroutine调用Lock方法请求锁的时候，通过atomic.AddInt32方法原子性的给key加1，如果比较幸运，当前没有等待者，那么key的值就会等于1，成功获取到锁；如果锁已经被别的 goroutine 持有了，当前的 goroutine 会在将 key 加 1的同时，调用 runtime.Semacquire 方法，使用信号量将自己休眠，等锁释放的时候，信号量会将它唤醒。释放锁的操作也比较简单，就是原子性的给key减1，不过当减1之后值变成-1的时候，程序就会panic，例如没有请求锁，直接对锁进行释放就会panic这个错误；此外还有一种情况，\u003Cstrong\u003EMutex结构中的key是一个int32类型，它能表达的最大整数是40多亿，当争抢锁的goroutine数目达到这个阈值的时候，也会panic，但是这种情况在服务器资源有限的情况下，是不可能会发生的。\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E我们先来探讨两个问题：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E为什么请求锁时，需要使用原子操作？\u003C\u002Fli\u003E\n\u003Cli\u003E为什么需要信号量？它的实现机制是什么？\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 data-id=\"heading-1\"\u003E1.1 原子操作的必要性\u003C\u002Fh3\u003E\n\u003Cp\u003E我们先来看一个简单技术器程序 counter.go。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs language-go copyable\" lang=\"go\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Epackage\u003C\u002Fspan\u003E main\n\n\u003Cspan class=\"hljs-keyword\"\u003Eimport\u003C\u002Fspan\u003E (\n   \u003Cspan class=\"hljs-string\"\u003E\"fmt\"\u003C\u002Fspan\u003E\n   \u003Cspan class=\"hljs-string\"\u003E\"sync\"\u003C\u002Fspan\u003E\n)\n\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunc\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Emain\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-params\"\u003E()\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E {\n   \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002Fruntime.GOMAXPROCS(1)\u003C\u002Fspan\u003E\n   \u003Cspan class=\"hljs-keyword\"\u003Evar\u003C\u002Fspan\u003E counter \u003Cspan class=\"hljs-type\"\u003Eint64\u003C\u002Fspan\u003E\n   \u003Cspan class=\"hljs-keyword\"\u003Evar\u003C\u002Fspan\u003E wg sync.WaitGroup\n   wg.Add(\u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E)\n   \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E i := \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E; i &#x3C; \u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E; i++ {\n      \u003Cspan class=\"hljs-keyword\"\u003Ego\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunc\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-params\"\u003E()\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E {\n         \u003Cspan class=\"hljs-keyword\"\u003Edefer\u003C\u002Fspan\u003E wg.Done()\n         \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E j := \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E; j &#x3C; \u003Cspan class=\"hljs-number\"\u003E10000\u003C\u002Fspan\u003E; j++ {\n            counter++  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002Fatomic.AddInt64(&#x26;counter, 1)\u003C\u002Fspan\u003E\n         }\n      }()\n   }\n   wg.Wait()\n   fmt.Println(counter)\n}\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E我们启动2个goroutine并发的累加counter，每个goroutine将counter累加1万，运行程序大概率打印出来的counter值不会是2万，而是一个小于2万的数，每次运行结果都不一样。熟悉并发编程的读者应该早都看出了端倪，这段程序中存在竞态条件。counter++不是一个原子操作，它包含三个步骤：1.读取counter变量当前值；2.对counter当前值加1，保存到寄存器临时变量中；3.将临时变量的结果再保存到counter中。其中的每一个步骤，都有对应的汇编实现。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fp3-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002Fa61ee5a4e61b40c88532bcb7baa8f523~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"竞态goroutine.png\" loading=\"lazy\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E当我们使用一个CPU核心的时候(使用runtime.GOMAXPROCS(1)设置)，多次运行程序，似乎我们总能得到2万的准确计数，但是这并不是一个强保证，当我们使用\u003Ccode\u003Ego run -race counter.go\u003C\u002Fcode\u003E竞态检测就大概率能检测到这段程序对counter变量的内存有非同步的并发读写：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs language-bash copyable\" lang=\"bash\"\u003E==================\nWARNING: DATA RACE\nRead at 0x00c000136008 by goroutine 8:\n  main.main.func1()\n      \u002FUsers\u002Fguozhaoran\u002FgoCode\u002Fbasic\u002FgoConcurrent\u002Fmutex\u002Fexample.go:17 +0x78\n\nPrevious write at 0x00c000136008 by goroutine 7:\n  main.main.func1()\n      \u002FUsers\u002Fguozhaoran\u002FgoCode\u002Fbasic\u002FgoConcurrent\u002Fmutex\u002Fexample.go:17 +0x91\n\nGoroutine 8 (running) created at:\n  main.main()\n      \u002FUsers\u002Fguozhaoran\u002FgoCode\u002Fbasic\u002FgoConcurrent\u002Fmutex\u002Fexample.go:14 +0xe4\n\nGoroutine 7 (finished) created at:\n  main.main()\n      \u002FUsers\u002Fguozhaoran\u002FgoCode\u002Fbasic\u002FgoConcurrent\u002Fmutex\u002Fexample.go:14 +0xe4\n==================\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E所以解决方案就是使用atomic包，它非常适合于这种全局单体变量的原子性加减，而这种原子性的实现是不同的CPU架构硬件提供的能力，通过LOCK汇编指令锁定数据总线来完成。\u003Cstrong\u003E对于Mutex的应用场景，原子操作当然是必不可少的，它保证了多个goroutine对共享变量key累加的一致性\u003C\u002Fstrong\u003E。\u003C\u002Fp\u003E\n\u003Ch3 data-id=\"heading-2\"\u003E1.2 信号量\u003C\u002Fh3\u003E\n\u003Cp\u003E信号量的概念是荷兰计算机科学家 Edsger Dijkstra 在 1963 年左右提出来的，广泛应用在不同的操作系统中。在系统中，会给每一个进程一个信号量，代表每个进程目前的状态。未得到控制权的进程，会在特定的地方被迫停下来，等待可以继续进行的信号到来。\u003C\u002Fp\u003E\n\u003Cp\u003EDijkstra 在他的论文中为信号量定义了两个操作 P 和 V。P 操作（descrease、wait、acquire）是减少信号量的计数值，而 V 操作（increase、signal、release）是增加信号量的计数值。使用伪代码表示如下（中括号代表原子操作）：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs language-lua copyable\" lang=\"lua\"\u003E\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EV\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-params\"\u003E(semaphore S, integer I)\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E: \n    [S ← S + I]\n\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EP\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-params\"\u003E(semaphore S, integer I)\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E: \n    \u003Cspan class=\"hljs-keyword\"\u003Erepeat\u003C\u002Fspan\u003E: \n        [\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E S ≥ I: \n        S ← S − I \n        \u003Cspan class=\"hljs-keyword\"\u003Ebreak\u003C\u002Fspan\u003E]\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E可以看到，初始化信号量 S 有一个指定数量（n）的资源，它就像是一个有 n 个资源的池子。P 操作相当于请求资源，如果资源可用，就立即返回；如果没有资源或者不够，那么，它可以不断尝试或者阻塞等待。V 操作会释放自己持有的资源，把资源返还给信号量。信号量的值除了初始化的操作以外，只能由 P\u002FV 操作改变。\u003C\u002Fp\u003E\n\u003Cp\u003E现在，我们来总结下信号量的实现。初始化信号量：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E设定初始的资源的数量。\u003C\u002Fli\u003E\n\u003Cli\u003EP 操作：将信号量的计数值减去 1，\u003Cstrong\u003E如果新值已经为负，那么调用者会被阻塞并加入到等待队列中\u003C\u002Fstrong\u003E。否则，调用者会继续执行，并且获得一个资源。\u003C\u002Fli\u003E\n\u003Cli\u003EV 操作：将信号量的计数值加 1，如果先前的计数值为负，就说明有等待的 P 操作的调用者。它会从等待队列中取出一个等待的调用者，唤醒它，让它继续执行。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E在运行时，Go 内部使用信号量来控制 goroutine 的阻塞和唤醒。比如互斥锁的第二个字段sema，信号量的 P\u002FV 操作是通过函数实现的(Go内部运行时的信号量也是通过atomic和gopark实现的，具体实现可以看runtime\u002Fsema.go)。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs language-go copyable\" lang=\"go\"\u003E\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunc\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eruntime_Semacquire\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-params\"\u003E(s *\u003Cspan class=\"hljs-type\"\u003Euint32\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunc\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eruntime_SemacquireMutex\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-params\"\u003E(s *\u003Cspan class=\"hljs-type\"\u003Euint32\u003C\u002Fspan\u003E, lifo \u003Cspan class=\"hljs-type\"\u003Ebool\u003C\u002Fspan\u003E, skipframes \u003Cspan class=\"hljs-type\"\u003Eint\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunc\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eruntime_Semrelease\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-params\"\u003E(s *\u003Cspan class=\"hljs-type\"\u003Euint32\u003C\u002Fspan\u003E, handoff \u003Cspan class=\"hljs-type\"\u003Ebool\u003C\u002Fspan\u003E, skipframes \u003Cspan class=\"hljs-type\"\u003Eint\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E值得一提的是，\u003Cstrong\u003EGo运行时的信号量实现的是一个优先级等待队列，这也是当前阶段Mutex饥饿模式实现的基础\u003C\u002Fstrong\u003E。信号量的 P\u002FV 操作函数，可以将goroutine休眠后添加到优先级队列的头部或尾部；也可以从优先级队列的头部或尾部将goroutine取出唤醒。\u003C\u002Fp\u003E\n\u003Ch2 data-id=\"heading-3\"\u003E2. 互斥锁初步优化——给要抢锁的goroutine一次机会\u003C\u002Fh2\u003E\n\u003Cp\u003E解读完初版互斥锁的实现，读者可能会发现一个问题，当锁被持有的情况下，新到来争抢锁的goroutine直接被运行时的信号量休眠并添加到了优先队列中，虽然这样严格保证了锁争抢的先来先得顺序，但是goroutine的休眠和唤醒非常影响性能，针对这一点，Go开发者对Mutex做了一次大的调整。\u003C\u002Fp\u003E\n\u003Cp\u003Egithub地址：\u003Ca href=\"https:\u002F\u002Flink.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgolang%2Fgo%2Fblob%2Fweekly.2011-07-07%2Fsrc%2Fpkg%2Fsync%2Fmutex.go\" target=\"_blank\" title=\"https:\u002F\u002Fgithub.com\u002Fgolang\u002Fgo\u002Fblob\u002Fweekly.2011-07-07\u002Fsrc\u002Fpkg\u002Fsync\u002Fmutex.go\" ref=\"nofollow noopener noreferrer\"\u003E互斥锁进一步优化\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E此时的Mutex结构如下:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs language-go copyable\" lang=\"go\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Etype\u003C\u002Fspan\u003E Mutex \u003Cspan class=\"hljs-keyword\"\u003Estruct\u003C\u002Fspan\u003E {\n    state \u003Cspan class=\"hljs-type\"\u003Eint32\u003C\u002Fspan\u003E\n    sema  \u003Cspan class=\"hljs-type\"\u003Euint32\u003C\u002Fspan\u003E\n}\n\n\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E (\n    mutexLocked = \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E &#x3C;&#x3C; \u003Cspan class=\"hljs-literal\"\u003Eiota\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F mutex is locked\u003C\u002Fspan\u003E\n    mutexWoken\n    mutexWaiterShift = \u003Cspan class=\"hljs-literal\"\u003Eiota\u003C\u002Fspan\u003E\n)\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EMutex结构体的key被改成了state，代表的含义也被拆分成了三个。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fp3-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F349de742eca64696ae55e8cb210f20ca~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"第一版优化后的Mutex.png\" loading=\"lazy\"\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EMutexLocked：state的第一个位代表锁是否被持有\u003C\u002Fli\u003E\n\u003Cli\u003EMutexWoken：state的第二个位代表是否有唤醒的 goroutine\u003C\u002Fli\u003E\n\u003Cli\u003EMutexWaiters：state剩下的位代表的是等待此锁的 goroutine 数\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E在分析这个版本的代码之前，我们先来补充一个要用到的非常重要的知识点：CAS。\u003C\u002Fp\u003E\n\u003Ch3 data-id=\"heading-4\"\u003E2.1 自旋锁(CAS)及其实现原理\u003C\u002Fh3\u003E\n\u003Cp\u003ECAS指令的实现原理是将给定的值与内存中的值进行比较，如果是同一个值，就用新值替换掉内存中的值，然后返回。如果不是就返回第一步的比较，因此得名“自旋锁”。下面画一个图来描述一下CAS算法，并和Go语言中的atomic.CompareAndSwap函数簇做一个比较：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fp1-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F56df16fd67fe4e2782577c5abc3fd59d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"CAS工作原理图.png\" loading=\"lazy\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E有一点需要特别注意，\u003Cstrong\u003ECAS中值的比较与交换过程是原子性的，这个过程中如果有其他的goroutine修改了内存中的值，那么CAS会返回false\u003C\u002Fstrong\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003ECAS也是Mutex实现的基础，读者可能会有疑问：有了CAS为什么还要有信号量呢？\u003Cstrong\u003E其实无论是原子操作，还是自旋锁，都不适合长时间等待的情况，因为有很多资源（数据）它有一定的时间性，你想去获取它，CPU 并不能立即返回给你，而是要等待一段时间，才能把数据返回给你。这种情况，你用自旋锁来同步访问这种资源，你会发现这是对 CPU 时间的巨大浪费。当然Mutex的实现非常适合使用CAS\u003C\u002Fstrong\u003E。\u003C\u002Fp\u003E\n\u003Ch3 data-id=\"heading-5\"\u003E2.2 互斥锁初步优化后的Lock实现\u003C\u002Fh3\u003E\n\u003Cp\u003E介绍完了CAS，我们来看当前版本的Lock实现，直接上代码：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs language-go copyable\" lang=\"go\"\u003E\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunc\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-params\"\u003E(m *Mutex)\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E Lock() {\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Fast path: 幸运case，能够直接获取到锁\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E atomic.CompareAndSwapInt32(&#x26;m.state, \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E, mutexLocked) {\n        \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E\n    }\n\n    awoke := \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E {\n        old := m.state\n        \u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E := old | mutexLocked    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F新状态加锁\u003C\u002Fspan\u003E\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E old&#x26;mutexLocked != \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E {\n            \u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E = old + \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E&#x3C;&#x3C;mutexWaiterShift     \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F等待者数量加一\u003C\u002Fspan\u003E\n        }\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E awoke {\n            \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002Fgoroutine是被唤醒的，新状态清除唤醒标记\u003C\u002Fspan\u003E\n            \u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E &#x26;^= mutexWoken\n        }\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E atomic.CompareAndSwapInt32(&#x26;m.state, old, \u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E) { \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F设置新状态\u003C\u002Fspan\u003E\n            \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E old&#x26;mutexLocked == \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E {   \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F锁原状态未加锁\u003C\u002Fspan\u003E\n                \u003Cspan class=\"hljs-keyword\"\u003Ebreak\u003C\u002Fspan\u003E\n            }\n            runtime.Semacquire(&#x26;m.sema)  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F请求信号量\u003C\u002Fspan\u003E\n            awoke = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F设置唤醒标记\u003C\u002Fspan\u003E\n        }\n    }\n}\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E我们重点看一下对state的操作。首先通过CAS检测Mutex是否没有被goroutine持有并且没有等待者，如果是这样，那么当前goroutine很幸运，可以直接获取到锁，这也就是代码中标注的Fast path。\u003C\u002Fp\u003E\n\u003Cp\u003E如果当前goroutine不够幸运，那么会走到下边的循环检查阶段，for 循环不断尝试获取锁，如果获取不到，就通过 runtime.Semacquire(&#x26;m.sema) 休眠，休眠醒来之后 awoke 置为 true，尝试争抢锁。我们知道state有三个含义：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E通过\u003Ccode\u003Enew := old | mutexLocked\u003C\u002Fcode\u003E设置state中的mutexLocked，给Mutex加锁；\u003C\u002Fli\u003E\n\u003Cli\u003E通过\u003Ccode\u003Enew = old + 1&#x3C;&#x3C;mutexWaiterShift\u003C\u002Fcode\u003E给Mutex设置mutexWaiterShift，等待者加1；\u003C\u002Fli\u003E\n\u003Cli\u003E通过\u003Ccode\u003Enew &#x26;^= mutexWoken\u003C\u002Fcode\u003E给Mutex清除Mutex的唤醒标记。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E那么接下来\u003Ccode\u003Eatomic.CompareAndSwapInt32(&#x26;m.state, old, new)\u003C\u002Fcode\u003E执行成功说明给state设置了新值，就要区分两种情况考虑了，第一种情况是state新值中包含加锁成功了，那么直接break，goroutine抢到了锁，程序结束；否则只能说明state 只是清除 mutexWoken 标志或者增加一个 waiter 而已。\u003C\u002Fp\u003E\n\u003Cp\u003E这里的循环状态检查的代码有两种goroutine会同时执行：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E新来抢锁的goroutine(可能有多个)\u003C\u002Fli\u003E\n\u003Cli\u003E从信号量优先队列中唤醒的goroutine(最多只可能有一个)\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E上边的描述可能比较抽象，我们结合下边的流程图帮助理解一下吧：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fp9-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F26c0382433b84652a559a2dcb8201c82~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"互斥锁争抢的原理.png\" loading=\"lazy\"\u003E\u003C\u002Fp\u003E\n\u003Ch3 data-id=\"heading-6\"\u003E2.3 互斥锁初步优化后的Unlock实现\u003C\u002Fh3\u003E\n\u003Cp\u003EUnlock方法也变得复杂了，但是不像Lock，仔细研究一下，还是能看得懂的，下边是代码：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs language-go copyable\" lang=\"go\"\u003E\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunc\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-params\"\u003E(m *Mutex)\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E Unlock() {\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Fast path: drop lock bit.\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E := atomic.AddInt32(&#x26;m.state, -mutexLocked)  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F去掉锁状态\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E+mutexLocked)&#x26;mutexLocked == \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E {     \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F未被锁定的mutex释放锁会panic\u003C\u002Fspan\u003E\n        \u003Cspan class=\"hljs-built_in\"\u003Epanic\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E\"sync: unlock of unlocked mutex\"\u003C\u002Fspan\u003E)\n    }\n\n    old := \u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E {\n        \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F锁上没有goroutine等待或者有被唤醒的goroutine,或者又被别的goroutine加了锁,那么不需要做任何事情，返回即可\u003C\u002Fspan\u003E\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E old\u003E\u003EmutexWaiterShift == \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E || old&#x26;(mutexLocked|mutexWoken) != \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E {\n            \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E\n        }\n        \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F将mutexWaiterShift数量减1并设置mutexWoken为true\u003C\u002Fspan\u003E\n        \u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E = (old - \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E&#x3C;&#x3C;mutexWaiterShift) | mutexWoken\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E atomic.CompareAndSwapInt32(&#x26;m.state, old, \u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E) {     \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002FCAS设置成功，唤醒一个新的goroutine争抢锁即可\u003C\u002Fspan\u003E\n            runtime.Semrelease(&#x26;m.sema)\n            \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E\n        }\n        old = m.state   \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F记录当前mutex的状态，继续循环\u003C\u002Fspan\u003E\n    }\n}\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EUnlock方法先定义一个新变量将锁标志去掉，如果对一个未加锁的Mutex进行Unlock会panic，然后程序还需要进行一些额外的判断，并不能直接返回。下面情况之一调用Unlock的goroutine可以直接返回：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EMutex上没有waiter\u003C\u002Fli\u003E\n\u003Cli\u003EMutex又被别人上了锁\u003C\u002Fli\u003E\n\u003Cli\u003E有goroutine被唤醒了\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E否则，先设置Mutex中mutexWaiterShift减1，并标记mutexWoken为true，使用CAS方法如果设置成功，则从信号量的优先队列中唤醒一个goroutine，程序返回。否则记录当前mutex的状态，继续循环判断。直到返回为止。\u003C\u002Fp\u003E\n\u003Cp\u003E相比较最初版本的设计，这个版本的Sync.Mutex实现主要是给新来的goroutine一次获取到锁的机会，打破了原来先来先得的逻辑，代码的复杂度也增加了不少。\u003C\u002Fp\u003E\n\u003Ch2 data-id=\"heading-7\"\u003E3. 互斥锁进一步优化——给要抢锁的goroutine更多机会\u003C\u002Fh2\u003E\n\u003Cp\u003E我们前边对Sync.Mutex的优化是基于一种猜想：新来的争抢锁的goroutine很大概率上能够获取到锁！持有锁的goroutine在持有锁时间越短的情况下，这种概率越大，那么我们为什么不给争抢锁的goroutine更多机会呢？也就是让它们稍微等一会，如果等一会也获取不到，那么就乖乖的添加进信号量的优先队列就好了。实际上，Go官方团队也是这么做的。\u003C\u002Fp\u003E\n\u003Cp\u003Egihub地址：\u003Ca href=\"https:\u002F\u002Flink.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgolang%2Fgo%2Fblob%2Fgo1.5%2Fsrc%2Fsync%2Fmutex.go\" target=\"_blank\" title=\"https:\u002F\u002Fgithub.com\u002Fgolang\u002Fgo\u002Fblob\u002Fgo1.5\u002Fsrc\u002Fsync\u002Fmutex.go\" ref=\"nofollow noopener noreferrer\"\u003E给要抢锁的goroutine更多机会\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E我们来看一下代码：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs language-go copyable\" lang=\"go\"\u003E\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunc\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-params\"\u003E(m *Mutex)\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E Lock() {\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Fast path: 幸运case，能够直接获取到锁\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E atomic.CompareAndSwapInt32(&#x26;m.state, \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E, mutexLocked) {\n        \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E\n    }\n\n    awoke := \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E\n    iter := \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E {   \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 不管是新来的请求锁的goroutine, 还是被唤醒的goroutine，都不断尝试请求锁\u003C\u002Fspan\u003E\n        old := m.state\n        \u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E := old | mutexLocked    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F新状态加锁\u003C\u002Fspan\u003E\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E old&#x26;mutexLocked != \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E {   \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 锁还没被释放\u003C\u002Fspan\u003E\n            \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E runtime_canSpin(iter) {  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 还可以自旋\u003C\u002Fspan\u003E\n                \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E !awoke &#x26;&#x26; old&#x26;mutexWoken == \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E &#x26;&#x26; old\u003E\u003EmutexWaiterShift != \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E &#x26;&#x26;\n                    atomic.CompareAndSwapInt32(&#x26;m.state, old, old|mutexWoken) {\n                    awoke = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E\n                }\n                runtime_doSpin()\n                iter++\n                \u003Cspan class=\"hljs-keyword\"\u003Econtinue\u003C\u002Fspan\u003E    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F自旋，再次尝试获取锁\u003C\u002Fspan\u003E\n            }\n            \u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E = old + \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E&#x3C;&#x3C;mutexWaiterShift      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F等待者数量加一\u003C\u002Fspan\u003E\n        }\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E awoke {  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F唤醒状态，去掉标记\u003C\u002Fspan\u003E\n            \u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E &#x26;^= mutexWoken\n        }\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E atomic.CompareAndSwapInt32(&#x26;m.state, old, \u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E) { \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F设置新状态\u003C\u002Fspan\u003E\n            \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E old&#x26;mutexLocked == \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E {   \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F锁原状态未加锁\u003C\u002Fspan\u003E\n                \u003Cspan class=\"hljs-keyword\"\u003Ebreak\u003C\u002Fspan\u003E\n            }\n            runtime_Semacquire(&#x26;m.sema) \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F请求信号量\u003C\u002Fspan\u003E\n            awoke = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F设置信号量\u003C\u002Fspan\u003E\n            iter = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F重新设置自旋计数器\u003C\u002Fspan\u003E\n        }\n    }\n}\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这次的优化很小，只增加了runtime_canSpin的检测，有一个自旋计数器iter，如果抢锁的goroutine还能自旋的话，就自旋等待持有锁的goroutine释放锁，这样能够增大抢到锁的概率。\u003C\u002Fp\u003E\n\u003Cp\u003E我想读者应该对代码中的这部分很迷惑：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs language-ini copyable\" lang=\"ini\"\u003Eif !awoke &#x26;&#x26; old&#x26;\u003Cspan class=\"hljs-attr\"\u003EmutexWoken\u003C\u002Fspan\u003E == \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E &#x26;&#x26; old\u003E\u003EmutexWaiterShift != \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E &#x26;&#x26;\n                    atomic.CompareAndSwapInt32(&#x26;m.state, old, old|mutexWoken) {\n                    \u003Cspan class=\"hljs-attr\"\u003Eawoke\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E\n                }\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这四个&#x26;&#x26;符号确实让人眼花撩乱，不过结合上一小节对Sync.Mutex的解读，我们能分析出这段代码的用途。首先&#x26;&#x26;是短路运算符，有一个为false判断就不会进行下去了。\u003Ccode\u003E!awoke\u003C\u002Fcode\u003E表示程序逻辑是由新加入抢锁的goroutine进来的，而不是从sema优先级队列中唤醒的goroutine进来的；再然后如果Mutex的旧值是没有唤醒新的goroutine(\u003Ccode\u003Eold&#x26;mutexWoken == 0\u003C\u002Fcode\u003E)的并且有等待者(\u003Ccode\u003Eold\u003E\u003EmutexWaiterShift != 0\u003C\u002Fcode\u003E)的话，就尝试通过CAS给Mutex设置一个唤醒标记(\u003Ccode\u003Eatomic.CompareAndSwapInt32(&#x26;m.state, old, old|mutexWoken)\u003C\u002Fcode\u003E)，如果成功的话，将awoke设置为true，这样做可以让调用Unlock的goroutine快速返回，而不用从优先队列中再唤醒goroutine来争抢锁。\u003C\u002Fp\u003E\n\u003Cp\u003E经过这一版本的优化，我们可以看到，\u003Cstrong\u003ESync.Mutex对新加入抢锁的goroutine相当友好，表面上看这样似乎没有什么问题，能够让更多的goroutine在最短的时间内获取到锁。但是我们考虑一下那些一直在信号量优先队列中的等待者怎么办？锁有可能一直被新来的goroutine抢到，这就产生了“饥饿问题”\u003C\u002Fstrong\u003E。\u003C\u002Fp\u003E\n\u003Ch2 data-id=\"heading-8\"\u003E4.终极版本的互斥锁——小康社会，不再饥饿\u003C\u002Fh2\u003E\n\u003Cp\u003ESync.Mutex的“饥饿问题”早在Go 1.9版本中就解决了，后续也进行了一些优化工作，到此Sync.Mutex才算是实现的比较完美。我们接下来会解读当前最新版本Go1.17的代码实现，读者要和我一起开启烧脑模式，细细的品一品了。\u003C\u002Fp\u003E\n\u003Cp\u003Egithub地址：\u003Ca href=\"https:\u002F\u002Flink.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgolang%2Fgo%2Fblob%2Fgo1.17rc1%2Fsrc%2Fsync%2Fmutex.go\" target=\"_blank\" title=\"https:\u002F\u002Fgithub.com\u002Fgolang\u002Fgo\u002Fblob\u002Fgo1.17rc1\u002Fsrc\u002Fsync\u002Fmutex.go\" ref=\"nofollow noopener noreferrer\"\u003E终极版本的Sync.Mutex\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Ch3 data-id=\"heading-9\"\u003E4.1 Mutex结构体实现\u003C\u002Fh3\u003E\n\u003Cp\u003E为了解决饥饿问题，Mutex结构体从state字段中又分出一个位标识当前Mutex是否饥饿，并定义了一个常量，将获取锁的goroutine等待时间设置了 1 毫秒阈值。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fp3-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002Faac838c01ab04e3792b29c4736435b23~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"终极版本的Mutex.png\" loading=\"lazy\"\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs language-go copyable\" lang=\"go\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Etype\u003C\u002Fspan\u003E Mutex \u003Cspan class=\"hljs-keyword\"\u003Estruct\u003C\u002Fspan\u003E {\n    state \u003Cspan class=\"hljs-type\"\u003Eint32\u003C\u002Fspan\u003E\n    sema  \u003Cspan class=\"hljs-type\"\u003Euint32\u003C\u002Fspan\u003E\n}\n\n\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E (\n    mutexLocked = \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E &#x3C;&#x3C; \u003Cspan class=\"hljs-literal\"\u003Eiota\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F mutex is locked\u003C\u002Fspan\u003E\n    mutexWoken\n    mutexStarving   \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 从state字段中分出一个饥饿标记\u003C\u002Fspan\u003E\n    mutexWaiterShift = \u003Cspan class=\"hljs-literal\"\u003Eiota\u003C\u002Fspan\u003E\n\n    starvationThresholdNs = \u003Cspan class=\"hljs-number\"\u003E1e6\u003C\u002Fspan\u003E   \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F1000000ns = 1ms\u003C\u002Fspan\u003E\n)\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 data-id=\"heading-10\"\u003E4.2 Sync.Mutex 终极版本的Lock函数实现\u003C\u002Fh3\u003E\n\u003Cp\u003E最新版本的Sync.Mutex的Lock方法和Unlock方法将fast path 和slow path拆成独立的函数，以便内联，提高性能。本节我们先来看一下Lock方法的实现：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs language-go copyable\" lang=\"go\"\u003E\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunc\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-params\"\u003E(m *Mutex)\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E Lock() {\n\t\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Fast path: 顺利的获取到锁\u003C\u002Fspan\u003E\n\t\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E atomic.CompareAndSwapInt32(&#x26;m.state, \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E, mutexLocked) {\n\t\t\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E race.Enabled {\n\t\t\trace.Acquire(unsafe.Pointer(m))\n\t\t}\n\t\t\u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E\n\t}\n\t\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Slow path (缓慢之路，通过自旋、竞争或者饥饿状态下的锁竞争)\u003C\u002Fspan\u003E\n\tm.lockSlow()\n}\n\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunc\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-params\"\u003E(m *Mutex)\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E lockSlow() {\n\t\u003Cspan class=\"hljs-keyword\"\u003Evar\u003C\u002Fspan\u003E waitStartTime \u003Cspan class=\"hljs-type\"\u003Eint64\u003C\u002Fspan\u003E\n\tstarving := \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E       \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F标识当前goroutine是否饥饿\u003C\u002Fspan\u003E\n\tawoke := \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F唤醒标记\u003C\u002Fspan\u003E\n\titer := \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E   \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F自旋次数\u003C\u002Fspan\u003E\n\told := m.state  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F当前的锁状态\u003C\u002Fspan\u003E\n\t\u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E {\n\t\t\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F锁是非饥饿状态，并且未释放，尝试自旋\u003C\u002Fspan\u003E\n\t\t\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E old&#x26;(mutexLocked|mutexStarving) == mutexLocked &#x26;&#x26; runtime_canSpin(iter) {\n\t\t\t\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 主动自旋的场景\u003C\u002Fspan\u003E\n\t\t\t\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 尝试设置 mutexWoken 标志以通知 Unlock 不唤醒其他阻塞的 goroutine\u003C\u002Fspan\u003E\n\t\t\t\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E !awoke &#x26;&#x26; old&#x26;mutexWoken == \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E &#x26;&#x26; old\u003E\u003EmutexWaiterShift != \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E &#x26;&#x26;\n\t\t\t\tatomic.CompareAndSwapInt32(&#x26;m.state, old, old|mutexWoken) {\n\t\t\t\tawoke = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E\n\t\t\t}\n\t\t\truntime_doSpin()    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F自旋\u003C\u002Fspan\u003E\n\t\t\titer++\n\t\t\told = m.state\n\t\t\t\u003Cspan class=\"hljs-keyword\"\u003Econtinue\u003C\u002Fspan\u003E\n\t\t}\n\t\t\u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E := old\n\t\t\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 不要尝试获取饥饿的互斥锁，新到达的 goroutine 必须排队\u003C\u002Fspan\u003E\n\t\t\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E old&#x26;mutexStarving == \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E {\n\t\t\t\u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E |= mutexLocked  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F非饥饿状态，加锁\u003C\u002Fspan\u003E\n\t\t}\n\t\t\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E old&#x26;(mutexLocked|mutexStarving) != \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E {   \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F饥饿状态，或者锁被抢占，等待者 + 1\u003C\u002Fspan\u003E\n\t\t\t\u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E += \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E &#x3C;&#x3C; mutexWaiterShift\n\t\t}\n\t\t\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 当前 goroutine 将互斥锁切换到饥饿模式。\u003C\u002Fspan\u003E\n\t\t\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E starving &#x26;&#x26; old&#x26;mutexLocked != \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E {\n\t\t\t\u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E |= mutexStarving\n\t\t}\n\t\t\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E awoke {\n\t\t\t\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F清除awoke标识\u003C\u002Fspan\u003E\n\t\t\t\u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E &#x26;^= mutexWoken\n\t\t}\n\t\t\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E atomic.CompareAndSwapInt32(&#x26;m.state, old, \u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E) {\n\t\t\t\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E old&#x26;(mutexLocked|mutexStarving) == \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E {\n\t\t\t\t\u003Cspan class=\"hljs-keyword\"\u003Ebreak\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 上锁成功\u003C\u002Fspan\u003E\n\t\t\t}\n\t\t\t\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 第一次等待，添加到信号量队列的队首\u003C\u002Fspan\u003E\n\t\t\tqueueLifo := waitStartTime != \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E\n\t\t\t\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E waitStartTime == \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E {\n\t\t\t\twaitStartTime = runtime_nanotime()\n\t\t\t}\n\t\t\truntime_SemacquireMutex(&#x26;m.sema, queueLifo, \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E)\n            \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F设置饥饿标记\u003C\u002Fspan\u003E\n\t\t\tstarving = starving || runtime_nanotime()-waitStartTime \u003E starvationThresholdNs\n\t\t\told = m.state\n\t\t\t\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E old&#x26;mutexStarving != \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E {\n\t\t\t\t\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F加锁并将waiter数量减1\u003C\u002Fspan\u003E\n\t\t\t\tdelta := \u003Cspan class=\"hljs-type\"\u003Eint32\u003C\u002Fspan\u003E(mutexLocked - \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E&#x3C;&#x3C;mutexWaiterShift)\n\t\t\t\t\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E !starving || old\u003E\u003EmutexWaiterShift == \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E {\n\t\t\t\t\t\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F非饥饿状态的goroutine,最后一个waiter已经不饥饿了，清除标记\u003C\u002Fspan\u003E\n\t\t\t\t\tdelta -= mutexStarving\n\t\t\t\t}\n\t\t\t\tatomic.AddInt32(&#x26;m.state, delta)\n\t\t\t\t\u003Cspan class=\"hljs-keyword\"\u003Ebreak\u003C\u002Fspan\u003E\n\t\t\t}\n\t\t\tawoke = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E\n\t\t\titer = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E\n\t\t} \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n\t\t\told = m.state\n\t\t}\n\t}\n}\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E代码结合注释也很难看懂，再结合流程图看一下。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fp3-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F492caf4e05f04a609bc3f0b2ba6be10d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"Mutex抢锁大致流程 (1).png\" loading=\"lazy\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E获取锁的goroutine很幸运的话，可以通过Fast path很快获取锁，我们来一步步分析一下lockSlow函数的实现。\n首先定义了当前goroutine用到的一些变量信息，然后使用old保存当前锁的状态。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs language-go copyable\" lang=\"go\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Evar\u003C\u002Fspan\u003E waitStartTime \u003Cspan class=\"hljs-type\"\u003Eint64\u003C\u002Fspan\u003E\n\tstarving := \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E   \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F标识当前goroutine是否饥饿模式\u003C\u002Fspan\u003E\n\tawoke := \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F唤醒标记，初次进入for循环为false，之后以从sema优先队列中唤醒的身份进入for循环\u003C\u002Fspan\u003E\n\titer := \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E   \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F自旋次数，用来判断是否可以继续自旋获取锁\u003C\u002Fspan\u003E\nold := m.state  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F当前的锁状态        \u003C\u002Fspan\u003E\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E然后代码就进入到了for循环，\u003Cstrong\u003ElockSlow的实现效果是尽可能少的循环，但是一定使获取锁的goroutine得到锁\u003C\u002Fstrong\u003E。for循环中，当前抢锁的goroutine发现锁还没有被释放(正常模式下)，则调用runtime_canSpin自旋等待一会，期望锁能够被释放，这期间，程序还做了其他一些事情，比如通过设置Mutex的awoke状态，尽量使得Unlock程序不要再唤醒sema优先队列中的goroutine了，因为参与竞争锁的goroutine越多，得到锁的概率越小！\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs language-scss copyable\" lang=\"scss\"\u003E\tfor {\n\t\t\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F锁是非饥饿状态，并且未释放，尝试自旋\u003C\u002Fspan\u003E\n\t\tif old&#x26;(mutexLocked|mutexStarving) == mutexLocked &#x26;&#x26; \u003Cspan class=\"hljs-built_in\"\u003Eruntime_canSpin\u003C\u002Fspan\u003E(iter) {\n\t\t\t\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 主动自旋的场景\u003C\u002Fspan\u003E\n\t\t\t\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 尝试设置 mutexWoken 标志以通知 Unlock 不唤醒其他阻塞的 goroutine\u003C\u002Fspan\u003E\n\t\t\tif !awoke &#x26;&#x26; old&#x26;mutexWoken == \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E &#x26;&#x26; old\u003E\u003EmutexWaiterShift != \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E &#x26;&#x26;\n\t\t\t\tatomic\u003Cspan class=\"hljs-selector-class\"\u003E.CompareAndSwapInt32\u003C\u002Fspan\u003E(&#x26;m.state, old, old|mutexWoken) {\n\t\t\t\tawoke = true\n\t\t\t}\n\t\t\t\u003Cspan class=\"hljs-built_in\"\u003Eruntime_doSpin\u003C\u002Fspan\u003E()    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F自旋\u003C\u002Fspan\u003E\n\t\t\titer++\n\t\t\told = m\u003Cspan class=\"hljs-selector-class\"\u003E.state\u003C\u002Fspan\u003E\n\t\t\tcontinue\n\t\t}\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E自旋等待之后，获取锁的goroutine命运有两个：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E当前锁已经被释放了，那么它就可以参与竞争了\u003C\u002Fli\u003E\n\u003Cli\u003E当前锁没有被释放，又或者它参与锁竞争失败了，那么它就要进入sema的优先队列了\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E不过不管结果如何，它都要走下边的通用逻辑，就是给Mutex设置新状态。有下边几个步骤：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E判断锁的状态是否是正常模式，是的话就设置mutexLocked标志准备抢锁\u003C\u002Fli\u003E\n\u003Cli\u003E如果锁的状态是没有被释放，或者是饥饿模式的话，当前goroutine一定要进sema优先队列了，这时候设置锁的等待者+1\u003C\u002Fli\u003E\n\u003Cli\u003E如果锁已经被标记为饥饿模式了，并且原来锁并没有被释放，那么将锁给打上饥饿的标记。有的读者可能会问了，为什么只有锁没有被释放的时候才打上饥饿标记呢？这是因为Unlock方法是根据锁是否为饥饿模式来从sema优先队列中唤醒goroutine的，也就是\u003Cstrong\u003E锁为饥饿模式时，优先队列中必须还有等待的goroutine\u003C\u002Fstrong\u003E。\u003C\u002Fli\u003E\n\u003Cli\u003E如果有awoke标记的话，将锁上的mutexWoken标记给擦除掉，因为不管当前goroutine最终进入sema优先队列还是获取到锁，新状态都应该清楚awoke标记。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs language-go copyable\" lang=\"go\"\u003E                \u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E := old\n\t\t\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 不要尝试获取饥饿的互斥锁，新到达的 goroutine 必须排队\u003C\u002Fspan\u003E\n\t\t\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E old&#x26;mutexStarving == \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E {\n\t\t\t\u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E |= mutexLocked  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F非饥饿状态，加锁\u003C\u002Fspan\u003E\n\t\t}\n\t\t\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E old&#x26;(mutexLocked|mutexStarving) != \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E {   \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F饥饿状态，或者锁被抢占，等待者 + 1\u003C\u002Fspan\u003E\n\t\t\t\u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E += \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E &#x3C;&#x3C; mutexWaiterShift\n\t\t}\n\t\t\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 当前 goroutine 将互斥锁切换到饥饿模式。\u003C\u002Fspan\u003E\n\t\t\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E starving &#x26;&#x26; old&#x26;mutexLocked != \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E {\n\t\t\t\u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E |= mutexStarving\n\t\t}\n\t\t\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E awoke {\n\t\t\t\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F清除awoke标识\u003C\u002Fspan\u003E\n\t\t\t\u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E &#x26;^= mutexWoken\n\t\t}\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E设置状态的步骤走完了，接下来就是CAS了，有两个结局：CAS成功 or CAS失败。\u003Cstrong\u003E失败是成功之母，CAS失败记录当前锁的状态，再次走for循环就好了，注意这时候不用更新spin计数，因为抢锁失败并没有进入sema优先队列\u003C\u002Fstrong\u003E！当然CAS成功了也并不是万事大吉了，如果锁是在正常情况下被上锁成功的话，那么恭喜当前goroutine成功获取到了锁；否则是一定要进入sema优先队列的，但是具体是被插入到头部还是尾部，则要分情况而定，这时候waitStartTime就发挥作用了，根据它不仅能判断出来抢锁的goroutine是否是第一次要被插入sema优先队列，还能判断当前锁状态是否已经达到饥饿阈值了。\u003C\u002Fp\u003E\n\u003Cp\u003E我们先来说goroutine是否是第一次要被插入sema优先队列的情况，是插入到尾部，这样只能等到下一轮调度唤醒了；如果当前goroutine不是第一次插入到sema优先队列，程序会将它插入到头部，这样下一个唤醒的依然是它，增加了它获取到锁的概率！\u003C\u002Fp\u003E\n\u003Cp\u003E计算当前锁状态模式的代码是goroutine从sema优先队列中被唤醒之后，根据waitStartTime的记录和上边starving的标识，如果当前goroutine等待锁时间超过了1ms，那么当前goroutine就会将锁标记为饥饿(注意这个时候并没有给Mutex打上饥饿的标识，只是标记为饥饿，如果接下来当前goroutine仍然获取不到锁，那么接下来的循环中会做这个事情)。这个时候再次判断锁的状态，如果锁为饥饿模式，那么就直接把锁交给当前请求锁的goroutine就好了，否则当前被唤醒的goroutine只能进行新一轮抢锁了(重新设置自旋计数器)。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs language-ini copyable\" lang=\"ini\"\u003Eif atomic.CompareAndSwapInt32(&#x26;m.state, old, new) {\n\t\t\tif old&#x26;(mutexLocked|mutexStarving) == 0 {\n\t\t\t\tbreak \u002F\u002F 上锁成功\n\t\t\t}\n\t\t\t\u002F\u002F 第一次等待，添加到信号量队列的队首\n\t\t\tqueueLifo := waitStartTime != 0\n\t\t\tif \u003Cspan class=\"hljs-attr\"\u003EwaitStartTime\u003C\u002Fspan\u003E == \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E {\n\t\t\t\t\u003Cspan class=\"hljs-attr\"\u003EwaitStartTime\u003C\u002Fspan\u003E = runtime_nanotime()\n\t\t\t}\n\t\t\truntime_SemacquireMutex(&#x26;m.sema, queueLifo, 1)\n            \u002F\u002F设置饥饿标记\n\t\t\t\u003Cspan class=\"hljs-attr\"\u003Estarving\u003C\u002Fspan\u003E = starving || runtime_nanotime()-waitStartTime \u003E starvationThresholdNs\n\t\t\t\u003Cspan class=\"hljs-attr\"\u003Eold\u003C\u002Fspan\u003E = m.state\n\t\t\tif old&#x26;mutexStarving != 0 {\n\t\t\t\t\u002F\u002F加锁并将waiter数量减1\n\t\t\t\tdelta := int32(mutexLocked - 1&#x3C;&#x3C;mutexWaiterShift)\n\t\t\t\tif !starving || old\u003E\u003E\u003Cspan class=\"hljs-attr\"\u003EmutexWaiterShift\u003C\u002Fspan\u003E == \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E {\n\t\t\t\t\t\u002F\u002F非饥饿状态的goroutine,最后一个waiter已经不饥饿了，清除标记\n\t\t\t\t\tdelta \u003Cspan class=\"hljs-attr\"\u003E-\u003C\u002Fspan\u003E= mutexStarving\n\t\t\t\t}\n\t\t\t\tatomic.AddInt32(&#x26;m.state, delta)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t\u003Cspan class=\"hljs-attr\"\u003Eawoke\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E\n\t\t\t\u003Cspan class=\"hljs-attr\"\u003Eiter\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E\n\t\t} else {\n\t\t\t\u003Cspan class=\"hljs-attr\"\u003Eold\u003C\u002Fspan\u003E = m.state\n\t\t}\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E以上就是终极版本Mutex的Lock函数实现，接下来回答几个常见问题：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Col\u003E\n\u003Cli\u003E如果Mutex已经被标记成为“饥饿模式”了，什么时候会变为“正常模式”呢？\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E拥有 Mutex 的 waiter 发现下面两种情况的其中之一，它就会把这个 Mutex 转换成正常模式；第一此 waiter 已经是队列中的最后一个 waiter 了(通过代码\u003Ccode\u003E!starving || old\u003E\u003EmutexWaiterShift == 1\u003C\u002Fcode\u003E判断)，没有其它的等待锁的 goroutine 了；第二是此 waiter 的等待时间小于 1 毫秒(通过代码\u003Ccode\u003Estarving = starving || runtime_nanotime()-waitStartTime \u003E starvationThresholdNs\u003C\u002Fcode\u003E判断)。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Col start=\"2\"\u003E\n\u003Cli\u003E为什么要有饥饿模式？\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E饥饿模式是对公平性和性能的一种平衡，它避免了某些 goroutine 长时间的等待锁。在饥饿模式下，优先对待的是那些一直在等待的 waiter。正常模式拥有更好的性能，因为即使有等待抢锁的 waiter，goroutine 也可以连续多次获取到锁。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Col start=\"3\"\u003E\n\u003Cli\u003E饥饿模式下Mutex是如何工作的?\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E饥饿模式下，会直接把锁交给队列第一个 goroutine。这块再代码中有体现。\u003C\u002Fp\u003E\n\u003Cp\u003E本节内容建议读着多读几遍，最好是从文章开始顺着历史发展的脉络思考，如果还有什么问题，可以在留言区和我一块交流。\u003C\u002Fp\u003E\n\u003Cp\u003E我们再接着看Unlock方法。\u003C\u002Fp\u003E\n\u003Ch3 data-id=\"heading-11\"\u003E4.3 Sync.Mutex 终极版本的Unlock函数实现\u003C\u002Fh3\u003E\n\u003Cp\u003E相对于Lock函数，Unlock函数的代码逻辑比较好理解，我们先看一下流程图：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fp6-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002Fe556320ebcdf45ecb1d240f10ff341a2~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"Mutex释放锁大致流程.png\" loading=\"lazy\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E代码如下：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs language-go copyable\" lang=\"go\"\u003E\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunc\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-params\"\u003E(m *Mutex)\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E Unlock() {\n\t\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Fast path: 将锁标记去掉\u003C\u002Fspan\u003E\n\t\u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E := atomic.AddInt32(&#x26;m.state, -mutexLocked)\n\t\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E != \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E {   \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F还需要做其他的事\u003C\u002Fspan\u003E\n\t\tm.unlockSlow(\u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E)\n\t}\n}\n\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunc\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-params\"\u003E(m *Mutex)\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E unlockSlow(\u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-type\"\u003Eint32\u003C\u002Fspan\u003E) {\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F无锁的mutex释放锁会panic\u003C\u002Fspan\u003E\n\t\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E+mutexLocked)&#x26;mutexLocked == \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E {\n\t\tthrow(\u003Cspan class=\"hljs-string\"\u003E\"sync: unlock of unlocked mutex\"\u003C\u002Fspan\u003E)\n\t}\n\t\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E&#x26;mutexStarving == \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E {\n\t\told := \u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E\n\t\t\u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E {\n\t\t\t\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F锁上没有goroutine等待或者有被唤醒的goroutine改变了锁的状态，直接return即可\u003C\u002Fspan\u003E\n\t\t\t\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E old\u003E\u003EmutexWaiterShift == \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E || old&#x26;(mutexLocked|mutexWoken|mutexStarving) != \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E {\n\t\t\t\t\u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E\n\t\t\t}\n\t\t\t\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 减少等待者并设置Mutex唤醒标记，CAS释放锁\u003C\u002Fspan\u003E\n\t\t\t\u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E = (old - \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E&#x3C;&#x3C;mutexWaiterShift) | mutexWoken\n\t\t\t\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E atomic.CompareAndSwapInt32(&#x26;m.state, old, \u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E) {\n\t\t\t\truntime_Semrelease(&#x26;m.sema, \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E)   \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F锁在正常模式下从sema优先队列尾部唤醒新的goroutine\u003C\u002Fspan\u003E\n\t\t\t\t\u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E\n\t\t\t}\n\t\t\told = m.state\n\t\t}\n\t} \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n\t\t\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F饥饿模式下，从优先队列的头部唤醒等待的goroutine，Lock方法会直接将锁给它\u003C\u002Fspan\u003E\n\t\truntime_Semrelease(&#x26;m.sema, \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E)\n\t}\n}\n\u003Cspan class=\"copy-code-btn\"\u003E复制代码\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E先将锁标记去掉，但是state其他字段并不为0的话，还需要做一些额外的工作，这就是\u003Ccode\u003EunlockSlow\u003C\u002Fcode\u003E的代码逻辑，如果是饥饿模式的话，从优先队列的头部唤醒一个goroutine，分析Lock代码的时候我们知道，饥饿模式下会将锁直接给这个唤醒的goroutine; 正常模式下进入for循环，如果锁的的其他状态已经被改变的情况下，unlockSlow什么也不需要做，return即可，否则将锁等待者数量-1，并设置唤醒标识，CAS操作成功之后，从sema优先队列尾部唤醒一个goroutine参与到抢锁工作中。\u003C\u002Fp\u003E\n\u003Cp\u003E以上就是Sync.Mutex终极版本的全部实现了。下边我们再来看一下Sync.Mutex使用中都有哪些坑。\u003C\u002Fp\u003E\n\u003Ch2 data-id=\"heading-12\"\u003E5. Sync.Mutex使用时常见的坑\u003C\u002Fh2\u003E\n\u003Cp\u003E关于Mutex的使用，一不小心就会产生死锁或者panic，使用不得当会有很大的性能开销，接下来我们结合上边的源码分析一下。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EMutex对goroutine无状态性\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E看过源代码，我们不难看出不同的goroutine操作Mutex这一个全局变量是没有状态记录的，这样会出现两种情况：1.一个goroutine可以释放掉另一个goroutine的锁；2.goroutine一旦重入设置两次Lock，就会死锁；建议使用Mutex时，Lock\u002FUnlock要成对出现，最好是封装到一个函数中，使用defer是一个好的方案。也可以对Mutex的无状态性做一个封装，例如实现锁的重入，添加一些锁的检测机制等等。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EMutex 千万不能被复制\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E这里所说的千万不能被复制并不是Go语言在语法上做了限制，而是在使用过程中，为了避免不必要的麻烦，不要拷贝Mutex，从源码分析我们看到，Mutex可以被千千万万个goroutine使用，拷贝Mutex时，只是拷贝的一个临时状态而已。复制之后，一个新 Mutex 可能莫名处于持有锁、唤醒或者饥饿状态，甚至等阻塞等待数量远远大于0。而原锁 Unlock 的时候，却不会影响复制锁。\u003C\u002Fp\u003E\n\u003Cp\u003E关于锁复制后产生的严重后果，推荐阅读：\u003Ca href=\"https:\u002F\u002Flink.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FOYGVR0d-fq1hgOvrdsUnYA\" target=\"_blank\" title=\"https:\u002F\u002Fmp.weixin.qq.com\u002Fs\u002FOYGVR0d-fq1hgOvrdsUnYA\" ref=\"nofollow noopener noreferrer\"\u003E当 Go struct 遇上 Mutex\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E产生强烈的锁竞争时怎么办\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E当线上QPS很高时，如果使用了Mutex，可能会发现大量的goroutine阻塞在Mutex的Lock函数上，这个时候就要想办法优化程序，首先应该尽量少使用Mutex，如果非要使用，可以采用分片管理数据的方式，Mutex保护的程序逻辑不应该过于复杂，因为大量goroutine阻塞在Mutex的Lock函数上会产生饥饿，饥饿带来的问题是性能更差，不能更快的恢复到正常模式将是一场灾难。\u003C\u002Fp\u003E\n\u003Cp\u003E关于锁竞争的优化，推荐阅读：\u003Ca href=\"https:\u002F\u002Flink.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FtcsSgCRj-tBDD7qyq53IAw\" target=\"_blank\" title=\"https:\u002F\u002Fmp.weixin.qq.com\u002Fs\u002FtcsSgCRj-tBDD7qyq53IAw\" ref=\"nofollow noopener noreferrer\"\u003E一次错误使用 go-cache 导致出现的线上问题\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Ch2 data-id=\"heading-13\"\u003E6. 小结\u003C\u002Fh2\u003E\n\u003Cp\u003EDDD设计中有关战略模型的分析指出，每一个复杂系统都有一个演进的过程，我们不要期望一次就将它做的很好。我觉得这个观点应用在Go语言的Sync.Mutex设计上非常恰当，“罗马不是一天建成的”，我们不得不佩服Sync.Mutex开发者的匠心精神，一次次打磨，精益求精的实现了现在的Sync.Mutex，虽然它可能还不够完美，还能够继续雕琢，但是这个发现问题并解决问题的思路和精神，是我们应该学习的。本文还分析了很多关于Sync.Mutex实现的基础知识：原子性、信号量、CAS；还指出了使用Mutex时应该注意的问题，希望感兴趣的读者在留言区继续和我交流！\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003EReference:\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003EMutex 源码分析:\n\u003Ca href=\"https:\u002F\u002Flink.juejin.cn?target=https%3A%2F%2Fcolobu.com%2F2018%2F12%2F18%2Fdive-into-sync-mutex%2F\" target=\"_blank\" title=\"https:\u002F\u002Fcolobu.com\u002F2018\u002F12\u002F18\u002Fdive-into-sync-mutex\u002F\" ref=\"nofollow noopener noreferrer\"\u003Ecolobu.com\u002F2018\u002F12\u002F18\u002F…\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E原子操作是如何实现的\n\u003Ca href=\"https:\u002F\u002Flink.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fluohaha%2FMyBlog%2Fissues%2F3\" target=\"_blank\" title=\"https:\u002F\u002Fgithub.com\u002Fluohaha\u002FMyBlog\u002Fissues\u002F3\" ref=\"nofollow noopener noreferrer\"\u003Egithub.com\u002Fluohaha\u002FMyB…\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E百度百科：信号量\n\u003Ca href=\"https:\u002F\u002Flink.juejin.cn?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%25E4%25BF%25A1%25E5%258F%25B7%25E9%2587%258F%2F9807501\" target=\"_blank\" title=\"https:\u002F\u002Fbaike.baidu.com\u002Fitem\u002F%E4%BF%A1%E5%8F%B7%E9%87%8F\u002F9807501\" ref=\"nofollow noopener noreferrer\"\u003Ebaike.baidu.com\u002Fitem\u002F%E4%BF…\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E一文彻底搞懂CAS实现原理\n\u003Ca href=\"https:\u002F\u002Flink.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F94762520\" target=\"_blank\" title=\"https:\u002F\u002Fzhuanlan.zhihu.com\u002Fp\u002F94762520\" ref=\"nofollow noopener noreferrer\"\u003Ezhuanlan.zhihu.com\u002Fp\u002F94762520\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003EGo sync.Mutex 深入不浅出\n\u003Ca href=\"https:\u002F\u002Fjuejin.cn\u002Fpost\u002F6984980411008958471\u002F#heading-10\" target=\"_blank\" title=\"https:\u002F\u002Fjuejin.cn\u002Fpost\u002F6984980411008958471\u002F#heading-10\"\u003Ejuejin.cn\u002Fpost\u002F698498…\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E一次错误使用 go-cache 导致出现的线上问题\n\u003Ca href=\"https:\u002F\u002Flink.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FtcsSgCRj-tBDD7qyq53IAw\" target=\"_blank\" title=\"https:\u002F\u002Fmp.weixin.qq.com\u002Fs\u002FtcsSgCRj-tBDD7qyq53IAw\" ref=\"nofollow noopener noreferrer\"\u003Emp.weixin.qq.com\u002Fs\u002FtcsSgCRj-…\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E当 Go struct 遇上 Mutex\n\u003Ca href=\"https:\u002F\u002Flink.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FOYGVR0d-fq1hgOvrdsUnYA\" target=\"_blank\" title=\"https:\u002F\u002Fmp.weixin.qq.com\u002Fs\u002FOYGVR0d-fq1hgOvrdsUnYA\" ref=\"nofollow noopener noreferrer\"\u003Emp.weixin.qq.com\u002Fs\u002FOYGVR0d-f…\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E",hitArticleCache:d,relatedLoaded:a,dynamicDataReady:a,actionType:{FETCH:"view\u002Fcolumn\u002FFETCH",FETCH_ADDITIONAL:"view\u002Fcolumn\u002FFETCH_ADDITIONAL",FETCH_SIDEBAR_ADENTRY:"view\u002Fcolumn\u002FFETCH_SIDEBAR_ADENTRY",FETCH_AUTHOR_EXTRA:"view\u002Fcolumn\u002FFETCH_AUTHOR_EXTRA",RESET:"view\u002Fcolumn\u002FRESET"},recommendedArticleList:{list:[],cursor:f,loading:a,skeleton:a,hasMore:a,articleId:e,actionType:{UPDATE_STATE:"view\u002Fcolumn\u002Frecommend-List\u002FUPDATE_STATE",FETCH_MORE:"view\u002Fcolumn\u002Frecommend-List\u002FFETCH_MORE",FETCH:"view\u002Fcolumn\u002Frecommend-List\u002FFETCH",RESET:"view\u002Fcolumn\u002Frecommend-List\u002FRESET"}}},collection:{collection:{author:{}},actionType:{FETCH:"@\u002Fview\u002Fcollection\u002FFETCH",REFRESH:"@\u002Fview\u002Fcollection\u002FREFRESH",RESET:"@\u002Fview\u002Fcollection\u002FRESET"},list:{pageSize:h,page:g,total:b,pointer:c,lastPointer:c,list:[],loading:a,error:c,canPrev:d,canNext:d,linkList:[],lastFetchOnServer:a,actionType:{UPDATE:"@\u002Fview\u002Fcollection\u002Flist\u002FUPDATE",FETCH:"@\u002Fview\u002Fcollection\u002Flist\u002FFETCH",FORCE_FETCH:"@\u002Fview\u002Fcollection\u002Flist\u002FFORCE_FETCH",FETCH_MORE:"@\u002Fview\u002Fcollection\u002Flist\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fcollection\u002Flist\u002FRESET"},id:e,sort:o}},gettingStarted:{category:{},actionType:{UPDATE_STATE:"@\u002Fview\u002FgettingStarted\u002FUPDATE_STATE",FOLLOW:"@\u002Fview\u002FgettingStarted\u002FFOLLOW",RESET:"@\u002Fview\u002FgettingStarted\u002FRESET",UPDATE_CATEGORY:"@\u002Fview\u002FgettingStarted\u002FUPDATE_CATEGORY"}},pin:{pin:{user:{},imageUrlList:[]},pinList:[],actionType:{FETCH:"@\u002Fview\u002Fpin\u002FFETCH",RESET:"@\u002Fview\u002Fpin\u002FRESET"},sidebar:{list:[],after:e,loading:a,isRecommend:a,hasNextPage:d,actionType:{UPDATE_STATE:"@\u002Fview\u002Fpin\u002Fsidebar\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fpin\u002Fsidebar\u002FFETCH_MORE",FETCH:"@\u002Fview\u002Fpin\u002Fsidebar\u002FFETCH",RESET:"@\u002Fview\u002Fpin\u002Fsidebar\u002FRESET"}},commentList:{pageSize:h,page:g,total:b,pointer:c,lastPointer:c,list:[],loading:a,error:c,canPrev:d,canNext:d,linkList:[],lastFetchOnServer:a,actionType:{UPDATE:"@\u002Fview\u002Fpin\u002FcommentList\u002FUPDATE",FETCH:"@\u002Fview\u002Fpin\u002FcommentList\u002FFETCH",FORCE_FETCH:"@\u002Fview\u002Fpin\u002FcommentList\u002FFORCE_FETCH",FETCH_MORE:"@\u002Fview\u002Fpin\u002FcommentList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fpin\u002FcommentList\u002FRESET"},pinId:c},subCommentList:{pageSize:h,page:g,total:b,pointer:c,lastPointer:c,list:[],loading:a,error:c,canPrev:d,canNext:d,linkList:[],lastFetchOnServer:a,actionType:{UPDATE:"@\u002Fview\u002Fpin\u002FsubCommentList\u002FUPDATE",FETCH:"@\u002Fview\u002Fpin\u002FsubCommentList\u002FFETCH",FORCE_FETCH:"@\u002Fview\u002Fpin\u002FsubCommentList\u002FFORCE_FETCH",FETCH_MORE:"@\u002Fview\u002Fpin\u002FsubCommentList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fpin\u002FsubCommentList\u002FRESET"},commentId:c}},topic:{topic:e,followedTopicList:[],actionType:{FETCH:"@\u002Fview\u002Ftopic\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Ftopic\u002FUPDATE_STATE",RESET:"@\u002Fview\u002Ftopic\u002FRESET"},allTopicList:{pageSize:M,page:b,total:b,pointer:c,lastPointer:c,list:[],loading:a,error:c,canPrev:d,canNext:d,linkList:[],lastFetchOnServer:a,actionType:{UPDATE:"@\u002Fview\u002Ftopic\u002FallTopicList\u002FUPDATE",FETCH:"@\u002Fview\u002Ftopic\u002FallTopicList\u002FFETCH",FORCE_FETCH:"@\u002Fview\u002Ftopic\u002FallTopicList\u002FFORCE_FETCH",FETCH_MORE:"@\u002Fview\u002Ftopic\u002FallTopicList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Ftopic\u002FallTopicList\u002FRESET"},sortType:n},pinlist:{pageSize:h,page:g,total:b,pointer:c,lastPointer:c,list:[],loading:a,error:c,canPrev:d,canNext:d,linkList:[],lastFetchOnServer:a,actionType:{UPDATE:"@\u002Fview\u002Ftopic\u002FpinList\u002FUPDATE",FETCH:"@\u002Fview\u002Ftopic\u002FpinList\u002FFETCH",FORCE_FETCH:"@\u002Fview\u002Ftopic\u002FpinList\u002FFORCE_FETCH",FETCH_MORE:"@\u002Fview\u002Ftopic\u002FpinList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Ftopic\u002FpinList\u002FRESET"},sortType:s},sidebar:{actionType:{RESET:"@\u002Fview\u002Ftopic\u002Fsidebar\u002FRESET",UPDATE_STATE:"@\u002Fview\u002Ftopic\u002Fsidebar\u002FUPDATE_STATE"},attender:{pageSize:h,page:g,total:b,pointer:c,lastPointer:c,list:[],loading:a,error:c,canPrev:d,canNext:d,linkList:[],lastFetchOnServer:a,actionType:{UPDATE:"@\u002Fview\u002Ftopic\u002Fsidebar\u002Fattender\u002FUPDATE",FETCH:"@\u002Fview\u002Ftopic\u002Fsidebar\u002Fattender\u002FFETCH",FORCE_FETCH:"@\u002Fview\u002Ftopic\u002Fsidebar\u002Fattender\u002FFORCE_FETCH",FETCH_MORE:"@\u002Fview\u002Ftopic\u002Fsidebar\u002Fattender\u002FFETCH_MORE",RESET:"@\u002Fview\u002Ftopic\u002Fsidebar\u002Fattender\u002FRESET"},topicId:c}},followedList:{pageSize:M,page:b,total:b,pointer:c,lastPointer:c,list:[],loading:a,error:c,canPrev:d,canNext:d,linkList:[],lastFetchOnServer:a,actionType:{UPDATE:"@\u002Fview\u002Ftopic\u002FfollowedList\u002FUPDATE",FETCH:"@\u002Fview\u002Ftopic\u002FfollowedList\u002FFETCH",FORCE_FETCH:"@\u002Fview\u002Ftopic\u002FfollowedList\u002FFORCE_FETCH",FETCH_MORE:"@\u002Fview\u002Ftopic\u002FfollowedList\u002FFETCH_MORE",RESET:"@\u002Fview\u002Ftopic\u002FfollowedList\u002FRESET"},after:b}},recommendationIndex:{actionType:{FETCH_USER:"@\u002Fview\u002Frecommendation\u002FFETCH_USER",FETCH_MORE:"@\u002Fview\u002Frecommendation\u002FFETCH_MORE",RESET:"@\u002Fview\u002Frecommendation\u002FRESET",FETCH:"@\u002Fview\u002Frecommendation\u002FFETCH"},cursor:e,hasMore:e,userList:[],loading:a,skeleton:d,category:l,categoryNavList:[],serverRenderUserList:a},event:{event:{},loading:a,user:{},actionType:{FETCH:"view\u002Fevent\u002FFETCH",RESET:"view\u002Fevent\u002FRESET"}},academyIndex:{academy:{},bannerList:[],qualitiedList:[],latestList:[],offlineList:[],loading:a,user:{},actionType:{FETCH:"view\u002Facademy\u002FFETCH",RESET:"view\u002Facademy\u002FRESET"}},coursesIndex:{loading:a,list:[],sort:"online",actionType:{FETCH:"view\u002Fcourses\u002FFETCH",RESET:"view\u002Fcourses\u002FRESET",FETCH_MORE:"view\u002Fcourses\u002FFETCH_MORE"}},team:{team:{},loading:d,actionType:{FETCH:"@\u002Fview\u002Fteam\u002FFETCH",RESET:"@\u002Fview\u002Fteam\u002FRESET",UPDATE:"@\u002Fview\u002Fteam\u002FUPDATE",FOLLOW:"@\u002Fview\u002Fteam\u002FFOLLOW"},detailList:{actionType:{RESET:"@\u002Fview\u002Fteam\u002FdetailList\u002FRESET"},posts:{list:[],hasMore:a,skeleton:a,loading:a,sort:o,actionType:{FETCH:"@\u002Fview\u002Fteam\u002FdetailList\u002Fposts\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fteam\u002FdetailList\u002Fposts\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fteam\u002FdetailList\u002Fposts\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fteam\u002FdetailList\u002Fposts\u002FRESET"}},pins:{list:[],hasMore:a,loading:a,skeleton:d,actionType:{FETCH:"@\u002Fview\u002Fteam\u002FdetailList\u002Fpins\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fteam\u002FdetailList\u002Fpins\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fteam\u002FdetailList\u002Fpins\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fteam\u002FdetailList\u002Fpins\u002FRESET"}},hire:{list:[],hasMore:a,cursor:f,loading:a,skeleton:d,actionType:{FETCH:"@\u002Fview\u002Fteam\u002FdetailList\u002Fhire\u002FFETCH",UPDATE_STATE:"@\u002Fview\u002Fteam\u002FdetailList\u002Fhire\u002FUPDATE_STATE",FETCH_MORE:"@\u002Fview\u002Fteam\u002FdetailList\u002Fhire\u002FFETCH_MORE",RESET:"@\u002Fview\u002Fteam\u002FdetailList\u002Fhire\u002FRESET"}}}},couponList:{list:{"0":v,"1":v,"2":v},showTooltip:a},payment:{selectedDiscount:{},bookletDetail:{},coupons:{availables:[],unavailables:[]},discountList:[]},activityVip:{selectedVipSku:{}}},component:{indexAside:{bannerList:[],userList:[],actionType:{FETCH_BANNER:"@\u002Fcomponent\u002Faside\u002FFETCH_BANNER",FETCH_USER:"@\u002Fcomponent\u002Faside\u002FFETCH_USER",CLOSE_BANNER:"@\u002Fcomponent\u002Faside\u002FCLOSE_BANNER"}}},ore:{oreCount:b},avatarMenuInfo:{user_basic:{},user_counter:{},user_growth_info:{}},common:{theme:"light"},env:{ua:"curl\u002F7.79.1",serverEnv:"production"},auth:{user:c,clientId:e,token:e,qrCode:c,qrCodeStatus:c,qrCodeToken:c},tag:{subscribedTagList:[]},entry:{isLikeLoading:a},collection:{},comment:{},bookComment:{},repoComment:{},category:{list:[]},user:{subscribedTagList:[]},notification:{unreadCount:{user:b,system:b,total:b}},follow:{subscribedTagList:[]},error:{location:c,errorView:c,statusCode:200,needRiskModal:a,riskAppealUrl:e},abTest:{info:{}},suspensionPanel:{needSuspension:d},pinComment:{},pin:{deleteDialogVisible:a,reportDialogVisible:a,targetPin:c,isOnFocus:a},topic:{visible:a},activity:{"2020":{},offer:{is_show:b,start_time:b},voteData:{err_no:b,err_msg:"success",data:{face:{title:e,activity_id:"8",start_time:p,end_time:1683648000,status:g,image:"https:\u002F\u002Fp3-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F8e01287320d847a881118c5e17e14131~tplv-k3u1fbpfcp-zoom-1.image",close_image:"https:\u002F\u002Fp3-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F882fc263e36347ffbf6d598de520870e~tplv-k3u1fbpfcp-image.image",url:"https:\u002F\u002Fjuejin.cn\u002Fpost\u002F7225552757607415865?utm_source=popup&utm_medium=app&utm_campaign=labourday",is_show:g},top:{title:w,activity_id:k,start_time:p,end_time:x,status:g,image:N,close_image:N,url:"https:\u002F\u002Fconf.juejin.cn\u002Fxdc2023\u002F?utm_source=appdhl",is_show:g},web_top:{title:w,activity_id:k,start_time:p,end_time:x,status:g,image:q,close_image:q,url:"https:\u002F\u002Fconf.juejin.cn\u002Fxdc2023\u002F?utm_source=jjwebdhl",is_show:g},plugin_top:{title:w,activity_id:k,start_time:p,end_time:x,status:g,image:q,close_image:q,url:"https:\u002F\u002Fconf.juejin.cn\u002Fxdc2023\u002F?utm_source=jcjdhl",is_show:g},search_top:{title:O,activity_id:k,start_time:P,end_time:1675612799,status:j,image:Q,close_image:R,url:S,is_show:b},web_search:{title:O,activity_id:k,start_time:P,end_time:1675612800,status:j,image:Q,close_image:R,url:S,is_show:b},jcode_top:{title:"码上掘金编程挑战赛",activity_id:k,start_time:1670846400,end_time:1671983999,status:j,image:T,close_image:T,url:"https:\u002F\u002Fjuejin.cn\u002Fchallenge?utm_source=code_nav",is_show:b},offer:{title:e,activity_id:"2020",start_time:1617638400,end_time:1618934400,status:j,image:"https:\u002F\u002Fp9-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F2879410508de459c91ae8b7509ca75f8~tplv-k3u1fbpfcp-zoom-1.image",close_image:"https:\u002F\u002Fp9-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002Fa38d640009e14c87a7d29cd95dee27dd~tplv-k3u1fbpfcp-zoom-1.image",url:"https:\u002F\u002Fjuejin-activity.bytedance.net\u002Frank",is_show:b}}}},header:{leadStep:b,isPopupZlink:a},tcc:{tccConfig:c},route:{name:"column",path:y,hash:e,query:{},params:{id:m},fullPath:y,meta:{},from:{name:c,path:U,hash:e,query:{},params:{},fullPath:U,meta:{}}}},serverRendered:d,routePath:y,config:{API_HOST:"api.juejin.cn",CAPTCHA_HOST:"verify.snssdk.com",PLATFORM_APPID:{wechat:1277,weibo:1276,github:1045,wechatApp:1070},SCM_VERSION:"1.0.0.7038",http:{}},globalRefs:{}}}(false,0,null,true,"","0",1,20,"topic",2,"2022","recommended","6990181431574003726","hot","newest",1682352000,"https:\u002F\u002Fp9-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002Fc94f4f5c114a4bf4b5f40ae5a8d6b805~tplv-k3u1fbpfcp-zoom-1.png","following","popular",void 0,7,{},"开发者大会",1687968000,"\u002Fpost\u002F6990181431574003726",3,"2101921964623992","【Go源码剖析】解读精益求精的 Sync.Mutex","“互斥锁”对于并发编程是必不可少的，Go语言虽然推崇使用Channel来解决对并发资源的访问，但同样实现了Sync.Mutex互斥锁供编程人员使用。本文就带领大家探索Sync.Mutex的实现。","deprecated","1627625845","6979922906226638885",3831,17,"烟花易冷DarkPrince",4,2794,{},100,"https:\u002F\u002Fp3-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F50071fb709124c998915dc39a0f41597~tplv-k3u1fbpfcp-zoom-1.png","开启我的2022年度报告",1672797600,"https:\u002F\u002Fp1-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F8a41831fce8b4c838f1807b2c86aea06~tplv-k3u1fbpfcp-zoom-1.image","https:\u002F\u002Fp9-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002Fe5199830276c4a85bc7c8cb8edecd54d~tplv-k3u1fbpfcp-image.image","https:\u002F\u002Fjuejin.cn\u002Freport2022\u002Fmobile?utm_source=search","https:\u002F\u002Fp6-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F759e2aa805c0461b840e0f0f09ed05fa~tplv-k3u1fbpfcp-zoom-1.image?","\u002F"));</script><script src="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/fab0e9f.js" defer></script><script src="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/523d86f.js" defer></script><script src="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/fd509fb.js" defer></script><script src="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/cdd39ba.js" defer></script><script src="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/fcf2e8d.js" defer></script><script src="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/254af3e.js" defer></script><script src="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/f6c285a.js" defer></script><script src="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/9c0af85.js" defer></script><script src="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/2eec92d.js" defer></script><script src="//lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/3421f55.js" defer></script>
  </body>
</html>
